@import "../../events/emitter.djinni"
@import "../../utils/callback.djinni"
@import "../amount.djinni"
@import "../../preferences/preferences.djinni"
@import "../../debug/logger.djinni"
@import "../bitcoin/bitcoin_like_wallet.djinni"
@import "../../bitcoin/addresses.djinni"
@import "currency.djinni"

OperationType = enum {
    send; receive;
}

TrustLevel = enum {
    trusted;
    almost_trustable;
    wait_for_trust;
    untrusted;
    dropped;
}

TrustIndicator = interface +c {
    getTrustWeight(): i32;
    getTrustLevel(): TrustLevel;
    getConflictingOperationUids(): list<string>;
    getOrigin(): string;
}

Operation = interface +c {
    getUid(): string;
    getAccountIndex(): i32;
    getOperationType(): OperationType;
    getDate(): date;
    getSenders(): list<string>;
    getRecipients(): list<string>;
    getAmount(): Amount;
    getFees(): optional<Amount>;
    getPreferences(): Preferences;
    getConfirmationsCount(): i32;
    getTrust(): TrustIndicator;

    asBitcoinLikeOperation(): BitcoinLikeOperation;
    ## asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
    ## asRippleLikeOperation(): Callback<RippleLikeEthereum>;
    isInstanceOfBitcoinLikeOperation(): bool;
    isInstanceOfEthereumLikeOperation(): bool;
    isInstanceOfRippleLikeOperation(): bool;


    isComplete(): bool;

    getWalletType(): WalletType;
}

Account = interface +c {
    getIndex(): i32;
    getOperations(from: i32, to: i32, descending: bool, complete: bool, callback: ListCallback<Operation>);
    getOperationsCount(callback: Callback<i64>);
    getOperation(uid: string, callback: Callback<Operation>);
    getBalance(callback: Callback<Amount>);
    isSynchronizing(): bool;
    synchronize(): EventBus;
    getPreferences(): Preferences;
    getLogger(): Logger;
    getOperationPreferences(uid: string): Preferences;
    # asBitcoinLikeAccount(): Callback<BitcoinLikeAccount>;
    # asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
    # asRippleLikeAccount(): Callback<RippleLikeAccount>;
    isInstanceOfBitcoinLikeAccount(): bool;
    isInstanceOfEthereumLikeAccount(): bool;
    isInstanceOfRippleLikeAccount(): bool;

    getWalletType(): WalletType;

    computeFees(amount: Amount, priority: i32, recipients: list<string>, data: list<binary>, callback: Callback<Amount>);
}

Wallet = interface +c {
    getName(): string;
    getAccount(index: i32, callback: Callback<Account>);
    getAccountCount(callback: Callback<i32>);
    getAccounts(offset: i32, count: i32, callback: ListCallback<Account>);
    getNextAccountIndex(callback: Callback<i32>);

    getEventBus(): EventBus;

    isSynchronizing(): bool;
    synchronize(): EventBus;
    getPreferences(): Preferences;
    getLogger(): Logger;

    getAccountPreferences(index: i32): Preferences;

    # asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
    # asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
    # asRippleLikeWallet(): Callback<RippleLikeWallet>;
    asBitcoinLikeWallet(): BitcoinLikeWallet;
    getCurrency(): Currency;
    isInstanceOfBitcoinLikeWallet(): bool;
    isInstanceOfEthereumLikeWallet(): bool;
    isInstanceOfRippleLikeWallet(): bool;
    getWalletType(): WalletType;
}