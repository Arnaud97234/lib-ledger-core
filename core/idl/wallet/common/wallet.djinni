@import "../../events/emitter.djinni"
@import "../../utils/callback.djinni"
@import "../amount.djinni"
@import "../../preferences/preferences.djinni"
@import "../../debug/logger.djinni"
@import "../bitcoin/bitcoin_like_wallet.djinni"
@import "../../bitcoin/addresses.djinni"
@import "currency.djinni"

#Class of synchronization status constants
SynchronizationStatus = interface +c {
    const STATUS_DONE: i32 = 1;
    const STATUS_ERROR: i32 = 2;
    const STATUS_DONE_SYNCHRONIZE_NEXT_ACCOUNT: i32 = 3;
}

#Enum of operation types
OperationType = enum {
    send; receive;
}

#Enum of transaction level of trust
TrustLevel = enum {
    trusted;
    pending;
    untrusted;
    dropped;
}

#TODO
TrustIndicator = interface +c {
    getTrustWeight(): i32;
    getTrustLevel(): TrustLevel;
    getConflictingOperationUids(): list<string>;
    getOrigin(): string;
}

#Structure of a block in the blockchain
Block = record {
    #String, block's hash
    hash: string;
    #String, id of block (usually height of block)
    uid: string;
    #Date on which block was mined
    time: date;
    #String, currency's name of blockchain the block belongs to
    currencyName: string;
    #64 bits integer, height of block in the blockchain
    height: i64;
}

#Class representing an operation
Operation = interface +c {
    #Get id's operation
    #@return string
    getUid(): string;
    #Get account's index in user's wallet
    #@return 32 bits integer
    getAccountIndex(): i32;
    #Get type of operation
    #@return OperationType object (for more details refer to OperationType)
    getOperationType(): OperationType;
    #Return date on which operation was issued
    #@return date object
    getDate(): date;
    #Get senders of operation
    #@return List of string, list of all senders
    getSenders(): list<string>;
    #Get recipients of operation
    #@return List of string, list of all recipients
    getRecipients(): list<string>;
    #Get amount of operation
    #@return Amount object
    getAmount(): Amount;
    #Get fees of operation
    #@return Optional Amount object
    getFees(): optional<Amount>;
    #Get preferences of operation
    #@return Prefences object
    getPreferences(): Preferences;
    #Get trust indicator of operation
    #@return TrustIndicator object
    getTrust(): TrustIndicator;
    #Get block height on which operation was included
    #@return Optional 64 bits integer, height of block in which operation was validated
    getBlockHeight(): optional<i64>;
    #Convert operation as Bitcoin operation
    #@return BitcoinLikeOperation object
    asBitcoinLikeOperation(): BitcoinLikeOperation;
    isInstanceOfBitcoinLikeOperation(): bool;
    #Same as asBitcoinLikeOperation for ethereum
    ## asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
    #Same as isInstanceOfBitcoinLikeOperation for ethereum
    isInstanceOfEthereumLikeOperation(): bool;
    #Same as asBitcoinLikeOperation for ripple
    ## asRippleLikeOperation(): Callback<RippleLikeOperation>;
    #Same as isInstanceOfBitcoinLikeOperation for ripple
    isInstanceOfRippleLikeOperation(): bool;
    #Tells if the operation is complete
    #@return boolean
    isComplete(): bool;
    #Get type of wallet from which operation was issued
    #@return WalletType object
    getWalletType(): WalletType;
}

OperationOrderKey = enum {
    date; amount; senders; recipients; type; currency_name; fees; block_height;
}

QueryFilter = interface +c {
    static accountEq(accountUid: string): QueryFilter;
    static accountNeq(accountUid: string): QueryFilter;
    static dateLte(time: date): QueryFilter;
    static dateLt(time: date): QueryFilter;
    static dateGt(time: date): QueryFilter;
    static dateGte(time: date): QueryFilter;
    static dateEq(time: date): QueryFilter;
    static dateNeq(time: date): QueryFilter;
    static containsRecipient(recipientAddress: string): QueryFilter;
    static containsSender(senderAddress: string): QueryFilter;
    static currencyEq(currencyName: string): QueryFilter;
    static operationUidEq(operationUid: string): QueryFilter;
    static operationUidNeq(operationUid: string): QueryFilter;
    static trustEq(trust: TrustLevel): QueryFilter;
    static trustNeq(trust: TrustLevel): QueryFilter;
    static feesEq(amount: Amount): QueryFilter;
    static feesNeq(amount: Amount): QueryFilter;
    static feesGte(amount: Amount): QueryFilter;
    static feesGt(amount: Amount): QueryFilter;
    static feesLte(amount: Amount): QueryFilter;
    static feesLt(amount: Amount): QueryFilter;
    static amountEq(amount: Amount): QueryFilter;
    static amountNeq(amount: Amount): QueryFilter;
    static amountGte(amount: Amount): QueryFilter;
    static amountGt(amount: Amount): QueryFilter;
    static amountLte(amount: Amount): QueryFilter;
    static amountLt(amount: Amount): QueryFilter;
    static blockHeightEq(blockHeight: i64): QueryFilter;
    static blockHeightNeq(blockHeight: i64): QueryFilter;
    static blockHeightGte(blockHeight: i64): QueryFilter;
    static blockHeightGt(blockHeight: i64): QueryFilter;
    static blockHeightLte(blockHeight: i64): QueryFilter;
    static blockHeightLt(blockHeight: i64): QueryFilter;
    static blockHeightIsNull(): QueryFilter;
    static operationTypeEq(operationType: OperationType): QueryFilter;
    static operationTypeNeq(operationType: OperationType): QueryFilter;

    op_and(filter: QueryFilter): QueryFilter;
    op_or(filter: QueryFilter): QueryFilter;
    op_and_not(filter: QueryFilter): QueryFilter;
    op_or_not(filter: QueryFilter): QueryFilter;
}

OperationQuery = interface +c {
    addOrder(key: OperationOrderKey, descending: bool): OperationQuery;
    filter(): QueryFilter;
    offset(from: i64): OperationQuery;
    limit(count: i64): OperationQuery;
    complete(): OperationQuery;
    partial(): OperationQuery;
    execute(callback: ListCallback<Operation>);
}

AccountCreationInfo = record {
    index: i32;
    owners: list<string>;
    derivations: list<string>;
    publicKeys: list<binary>;
    chainCodes: list<binary>;
}

ExtendedKeyAccountCreationInfo = record {
    index: i32;
    owners: list<string>;
    derivations: list<string>;
    extendedKeys: list<string>;
}

Account = interface +c {
    # Key of the synchronization duration time in the synchronize event payload.
    # The value is stored in a int 64 time expressed in miliseconds.
    const EV_SYNC_DURATION_MS: string = "EV_SYNC_DURATION_MS";
    # Key of the synchronization error code. The code is a stringified version of the value in the ErrorCode enum.
    const EV_SYNC_ERROR_CODE: string = "EV_SYNC_ERROR_CODE";
    # Key of the synchronization error message. The message is stored as a string.
    const EV_SYNC_ERROR_MESSAGE: string = "EV_SYNC_ERROR_MESSAGE";

    const EV_NEW_BLOCK_CURRENCY_NAME: string = "EV_NEW_BLOCK_CURRENCY_NAME";
    const EV_NEW_BLOCK_HASH: string = "EV_NEW_BLOCK_HASH";
    const EV_NEW_BLOCK_HEIGHT: string = "EV_NEW_BLOCK_HEIGHT";

    const EV_NEW_OP_WALLET_NAME: string = "EV_NEW_OP_WALLET_NAME";
    const EV_NEW_OP_ACCOUNT_INDEX: string = "EV_NEW_OP_ACCOUNT_INDEX";
    const EV_NEW_OP_UID: string = "EV_NEW_OP_UID";

    getIndex(): i32;
    queryOperations(): OperationQuery;
    getBalance(callback: Callback<Amount>);
    isSynchronizing(): bool;
    synchronize(): EventBus;
    getPreferences(): Preferences;
    getLogger(): Logger;
    getOperationPreferences(uid: string): Preferences;
    # asBitcoinLikeAccount(): Callback<BitcoinLikeAccount>;
    # asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
    # asRippleLikeAccount(): Callback<RippleLikeAccount>;
    isInstanceOfBitcoinLikeAccount(): bool;
    isInstanceOfEthereumLikeAccount(): bool;
    isInstanceOfRippleLikeAccount(): bool;
    getFreshPublicAddresses(callback: ListCallback<string>);
    getWalletType(): WalletType;
    getEventBus(): EventBus;

    startBlockchainObservation();
    stopBlockchainObservation();
    isObservingBlockchain(): bool;
    getLastBlock(callback: Callback<Block>);
    computeFees(amount: Amount, priority: i32, recipients: list<string>, data: list<binary>, callback: Callback<Amount>);
}

Wallet = interface +c {
    getName(): string;
    getAccount(index: i32, callback: Callback<Account>);
    getAccountCount(callback: Callback<i32>);
    getAccounts(offset: i32, count: i32, callback: ListCallback<Account>);
    getNextAccountIndex(callback: Callback<i32>);

    getEventBus(): EventBus;

    isSynchronizing(): bool;
    synchronize(): EventBus;
    getPreferences(): Preferences;
    getLogger(): Logger;

    getAccountPreferences(index: i32): Preferences;

    # asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
    # asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
    # asRippleLikeWallet(): Callback<RippleLikeWallet>;
    asBitcoinLikeWallet(): BitcoinLikeWallet;
    getCurrency(): Currency;
    isInstanceOfBitcoinLikeWallet(): bool;
    isInstanceOfEthereumLikeWallet(): bool;
    isInstanceOfRippleLikeWallet(): bool;
    getWalletType(): WalletType;
    getLastBlock(callback: Callback<Block>);
    getAccountCreationInfo(accountIndex: i32, callback: Callback<AccountCreationInfo>);
    getExtendedKeyAccountCreationInfo(accountIndex: i32, callback: Callback<ExtendedKeyAccountCreationInfo>);
    getNextAccountCreationInfo(callback: Callback<AccountCreationInfo>);
    getNextExtendedKeyAccountCreationInfo(callback: Callback<ExtendedKeyAccountCreationInfo>);
    newAccountWithInfo(accountCreationInfo: AccountCreationInfo, callback: Callback<Account>);
    newAccountWithExtendedKeyInfo(extendedKeyAccountCreationInfo: ExtendedKeyAccountCreationInfo, callback: Callback<Account>);
}