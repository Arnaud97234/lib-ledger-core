// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from dynamic.djinni

#import "RCTCoreLGDynamicArray.h"


@implementation RCTCoreLGDynamicArray
//Export module
RCT_EXPORT_MODULE(RCTCoreLGDynamicArray)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGDynamicArray alloc] init];
    }
    return self;
}

/**
 *Get count of stored references
 *@return 64 bits integer
 */
RCT_REMAP_METHOD(size,sizeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl size];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::size", nil);
    }
}

/**
 *Push a 32 bits integer
 *@param value, 32 bits integer
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushInt,pushInt:(int32_t)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushInt:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushInt", nil);
    }
}

/**
 *Push a 64 bits integer
 *@param value, 64 bits integer
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushLong,pushLong:(int64_t)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushLong:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushLong", nil);
    }
}

/**
 *Push a string
 *@param value, string
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushString,pushString:(nonnull NSString *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushString:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushString", nil);
    }
}

/**
 *Push a double
 *@param value, double
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushDouble,pushDouble:(double)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushDouble:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushDouble", nil);
    }
}

/**
 *Push a binary
 *@param value, binary
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushData,pushData:(nonnull NSData *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushData:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushData", nil);
    }
}

/**
 *Push a bool
 *@param value, bool
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushBoolean,pushBoolean:(BOOL)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushBoolean:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushBoolean", nil);
    }
}

/**
 *Push a DynamicObject object
 *@param value, DynamicObject
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushObject,pushObject:(nullable LGDynamicObject *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushObject:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushObject", nil);
    }
}

/**
 *Push a DynamicArray object
 *@param value, DynamicArray
 *@return DynamicArray with value stored in it
 */
RCT_REMAP_METHOD(pushArray,pushArray:(nullable LGDynamicArray *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pushArray:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::pushArray", nil);
    }
}

/**
 *Get string at a given index
 *@param index, 64 bits integer
 *@return Optional string
 */
RCT_REMAP_METHOD(getString,getString:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getString:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getString", nil);
    }
}

/**
 *Get 32 bits integer at a given index
 *@param index, 64 bits integer
 *@return Optional 32 bits integer
 */
RCT_REMAP_METHOD(getInt,getInt:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getInt:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getInt", nil);
    }
}

/**
 *Get 64 bits integer at a given index
 *@param index, 64 bits integer
 *@return Optional 64 bits integer
 */
RCT_REMAP_METHOD(getLong,getLong:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getLong:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getLong", nil);
    }
}

/**
 *Get double at a given index
 *@param index, 64 bits integer
 *@return Optional double
 */
RCT_REMAP_METHOD(getDouble,getDouble:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getDouble:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getDouble", nil);
    }
}

/**
 *Get binary at a given index
 *@param index, 64 bits integer
 *@return Optional binary
 */
RCT_REMAP_METHOD(getData,getData:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getData:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getData", nil);
    }
}

/**
 *Get bool at a given index
 *@param index, 64 bits integer
 *@return Optional bool
 */
RCT_REMAP_METHOD(getBoolean,getBoolean:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getBoolean:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getBoolean", nil);
    }
}

/**
 *Get DynamicObject object at a given index
 *@param index, 64 bits integer
 *@return Optional DynamicObject
 */
RCT_REMAP_METHOD(getObject,getObject:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getObject:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getObject", nil);
    }
}

/**
 *Get DynamicArray object at a given index
 *@param index, 64 bits integer
 *@return Optional DynamicArray
 */
RCT_REMAP_METHOD(getArray,getArray:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getArray:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getArray", nil);
    }
}

/**
 *Concatenate current DynamicArray with another one
 *@param array, DynamicArray object to concatenate with
 *@return DynamicArray object, concatenated DynamicArray
 */
RCT_REMAP_METHOD(concat,concat:(nullable LGDynamicArray *)array withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl concat:array];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::concat", nil);
    }
}

/**
 *Get type of value stored at a given index
 *@param index, 64 bits integer
 *@return Optional DynamicType enum entry
 */
RCT_REMAP_METHOD(getType,getType:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getType:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::getType", nil);
    }
}

/**
 *Delete value stored at given index
 *@param index, 64 bits integer
 *@return bool, true if deletion succeeded
 */
RCT_REMAP_METHOD(remove,remove:(int64_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl remove:index];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::remove", nil);
    }
}

/**
 *Dump whole object's content as string
 *@return string
 */
RCT_REMAP_METHOD(dump,dumpWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl dump];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::dump", nil);
    }
}

/**
 *Serialize whole object to a binary
 *@return binary
 */
RCT_REMAP_METHOD(serialize,serializeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl serialize];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::serialize", nil);
    }
}

/**
 *Get readonly status of object
 *@param bool
 */
RCT_REMAP_METHOD(isReadOnly,isReadOnlyWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl isReadOnly];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::isReadOnly", nil);
    }
}

/**
 *Create a new instance of DynamicArray class
 *@return DynamicArray instance
 */
RCT_REMAP_METHOD(newInstance,newInstanceWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGDynamicArray newInstance];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::newInstance", nil);
    }
}

/**
 *Parse a binary to a DynamicArray
 *@param serialized, binary to parse
 *@return Optional DynamicArray
 */
RCT_REMAP_METHOD(load,load:(nonnull NSData *)serialized withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGDynamicArray load:serialized];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicArray::load", nil);
    }
}
@end
