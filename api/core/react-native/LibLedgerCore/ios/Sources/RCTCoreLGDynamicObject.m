// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from dynamic.djinni

#import "RCTCoreLGDynamicObject.h"


@implementation RCTCoreLGDynamicObject
//Export module
RCT_EXPORT_MODULE(RCTCoreLGDynamicObject)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGDynamicObject alloc] init];
    }
    return self;
}

/**
 *Store a string with a given key
 *@param key, string, key to access stored value
 *@param value, string
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putString,putString:(nonnull NSString *)key
                               value:(nonnull NSString *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putString:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putString", nil);
    }
}

/**
 *Store a 32 bits integer with a given key
 *@param key, string, key to access stored value
 *@param value, 32 bits integer
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putInt,putInt:(nonnull NSString *)key
                         value:(int32_t)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putInt:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putInt", nil);
    }
}

/**
 *Store a 64 bits integer with a given key
 *@param key, string, key to access stored value
 *@param value, 64 bits integer
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putLong,putLong:(nonnull NSString *)key
                           value:(int64_t)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putLong:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putLong", nil);
    }
}

/**
 *Store a double with a given key
 *@param key, string, key to access stored value
 *@param value, double
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putDouble,putDouble:(nonnull NSString *)key
                               value:(double)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putDouble:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putDouble", nil);
    }
}

/**
 *Store a binary integer with a given key
 *@param key, string, key to access stored value
 *@param value, binary
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putData,putData:(nonnull NSString *)key
                           value:(nonnull NSData *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putData:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putData", nil);
    }
}

/**
 *Store a boolean integer with a given key
 *@param key, string, key to access stored value
 *@param value, bool
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putBoolean,putBoolean:(nonnull NSString *)key
                                 value:(BOOL)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putBoolean:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putBoolean", nil);
    }
}

/**
 *Store another DynamicObject object with a given key
 *@param key, string, key to access stored value
 *@return DynamicObject object with value stored in it
 */
RCT_REMAP_METHOD(putObject,putObject:(nonnull NSString *)key
                               value:(nullable LGDynamicObject *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putObject:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putObject", nil);
    }
}

/**
 *Store a DynamicArray object with a given key
 *@param key, string, key to access stored reference
 *@return DynamicArray object with value stored in it
 */
RCT_REMAP_METHOD(putArray,putArray:(nonnull NSString *)key
                             value:(nullable LGDynamicArray *)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl putArray:key value:value];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::putArray", nil);
    }
}

/**
 *Get, if exists, stored string having a specific key
 *@param key, string, key of string to look for
 *@return Optional string
 */
RCT_REMAP_METHOD(getString,getString:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getString:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getString", nil);
    }
}

/**
 *Get, if exists, stored 32 bits integer having a specific key
 *@param key, string, key of 32 bits integer to look for
 *@return Optional 32 bits integer
 */
RCT_REMAP_METHOD(getInt,getInt:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getInt:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getInt", nil);
    }
}

/**
 *Get, if exists, stored 64 bits integer having a specific key
 *@param key, string, key of 64 bits integer to look for
 *@return Optional 64 bits integer
 */
RCT_REMAP_METHOD(getLong,getLong:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getLong:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getLong", nil);
    }
}

/**
 *Get, if exists, stored double having a specific key
 *@param key, string, key of double to look for
 *@return Optional double
 */
RCT_REMAP_METHOD(getDouble,getDouble:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getDouble:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getDouble", nil);
    }
}

/**
 *Get, if exists, stored binary having a specific key
 *@param key, string, key of binary to look for
 *@return Optional binary
 */
RCT_REMAP_METHOD(getData,getData:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getData:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getData", nil);
    }
}

/**
 *Get, if exists, stored bool having a specific key
 *@param key, string, key of bool to look for
 *@return Optional bool
 */
RCT_REMAP_METHOD(getBoolean,getBoolean:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getBoolean:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getBoolean", nil);
    }
}

/**
 *Get, if exists, stored DynamicObject having a specific key
 *@param key, string, key of DynamicObject to look for
 *@return Optional DynamicObject
 */
RCT_REMAP_METHOD(getObject,getObject:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getObject:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getObject", nil);
    }
}

/**
 *Get, if exists, stored DynamicArray having a specific key
 *@param key, string, key of DynamicArray to look for
 *@return Optional DynamicArray
 */
RCT_REMAP_METHOD(getArray,getArray:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getArray:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getArray", nil);
    }
}

/**
 *Check if a key was used to store a value
 *@param key, string, key to look for
 *@return bool
 */
RCT_REMAP_METHOD(contains,contains:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl contains:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::contains", nil);
    }
}

/**
 *Delete key and value stored with it
 *@param key, string, key to look for
 *@return bool, true if key exists and deletion succeeded, false otherwise
 */
RCT_REMAP_METHOD(remove,remove:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl remove:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::remove", nil);
    }
}

/**
 *Get list of keys
 *@return list of string, list all stored keys
 */
RCT_REMAP_METHOD(getKeys,getKeysWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getKeys];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getKeys", nil);
    }
}

/**
 *Get type of object stored with specific key
 *@param key, string, key to look for
 *@return Optional DynamicType enum entry
 */
RCT_REMAP_METHOD(getType,getType:(nonnull NSString *)key withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getType:key];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::getType", nil);
    }
}

/**
 *Dump whole object's content as string
 *@return string
 */
RCT_REMAP_METHOD(dump,dumpWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl dump];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::dump", nil);
    }
}

/**
 *Serialize whole object to a binary
 *@return binary
 */
RCT_REMAP_METHOD(serialize,serializeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl serialize];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::serialize", nil);
    }
}

/**
 *Get readonly status of object
 *@param bool
 */
RCT_REMAP_METHOD(isReadOnly,isReadOnlyWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl isReadOnly];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::isReadOnly", nil);
    }
}

/**
 *Get count of stored references
 *@return 64 bits integer
 */
RCT_REMAP_METHOD(size,sizeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl size];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::size", nil);
    }
}

/**
 *Create a new instance of DynamicObject class
 *@return DynamicObject instance
 */
RCT_REMAP_METHOD(newInstance,newInstanceWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGDynamicObject newInstance];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::newInstance", nil);
    }
}

/**
 *Parse a binary to a DynamicObject
 *@param serialized, binary to parse
 *@return Optional DynamicObject
 */
RCT_REMAP_METHOD(load,load:(nonnull NSData *)serialized withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGDynamicObject load:serialized];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDynamicObject::load", nil);
    }
}
@end
