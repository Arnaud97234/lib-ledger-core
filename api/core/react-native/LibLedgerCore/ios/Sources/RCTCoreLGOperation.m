// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet.djinni

#import "RCTCoreLGOperation.h"


@implementation RCTCoreLGOperation
//Export module
RCT_EXPORT_MODULE(RCTCoreLGOperation)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGOperation alloc] init];
    }
    return self;
}

/**
 *Get id's operation
 *@return string
 */
RCT_REMAP_METHOD(getUid,getUidWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getUid]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getUid", nil);
    }
}

/**
 *Get account's index in user's wallet
 *@return 32 bits integer
 */
RCT_REMAP_METHOD(getAccountIndex,getAccountIndexWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl getAccountIndex])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getAccountIndex", nil);
    }
}

/**
 *Get type of operation
 *@return OperationType object (for more details refer to OperationType)
 */
RCT_REMAP_METHOD(getOperationType,getOperationTypeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl getOperationType])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getOperationType", nil);
    }
}

/**
 *Return date on which operation was issued
 *@return date object
 */
RCT_REMAP_METHOD(getDate,getDateWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getDate]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getDate", nil);
    }
}

/**
 *Get senders of operation
 *@return List of string, list of all senders
 */
RCT_REMAP_METHOD(getSenders,getSendersWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getSenders]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getSenders", nil);
    }
}

/**
 *Get recipients of operation
 *@return List of string, list of all recipients
 */
RCT_REMAP_METHOD(getRecipients,getRecipientsWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getRecipients]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getRecipients", nil);
    }
}

/**
 *Get amount of operation
 *@return Amount object
 */
RCT_REMAP_METHOD(getAmount,getAmountWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getAmount]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getAmount", nil);
    }
}

/**
 *Get fees of operation
 *@return Optional Amount object
 */
RCT_REMAP_METHOD(getFees,getFeesWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getFees]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getFees", nil);
    }
}

/**
 *Get preferences of operation
 *@return Prefences object
 */
RCT_REMAP_METHOD(getPreferences,getPreferencesWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getPreferences]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getPreferences", nil);
    }
}

/**
 *Get trust indicator of operation
 *@return TrustIndicator object
 */
RCT_REMAP_METHOD(getTrust,getTrustWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getTrust]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getTrust", nil);
    }
}

/**
 *Get block height on which operation was included
 *@return Optional 64 bits integer, height of block in which operation was validated
 */
RCT_REMAP_METHOD(getBlockHeight,getBlockHeightWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getBlockHeight]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getBlockHeight", nil);
    }
}

/**
 *Convert operation as Bitcoin operation
 *@return BitcoinLikeOperation object
 */
RCT_REMAP_METHOD(asBitcoinLikeOperation,asBitcoinLikeOperationWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl asBitcoinLikeOperation]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::asBitcoinLikeOperation", nil);
    }
}

RCT_REMAP_METHOD(isInstanceOfBitcoinLikeOperation,isInstanceOfBitcoinLikeOperationWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isInstanceOfBitcoinLikeOperation])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::isInstanceOfBitcoinLikeOperation", nil);
    }
}

/**
 *Same as asBitcoinLikeOperation for ethereum
 *# asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
 *Same as isInstanceOfBitcoinLikeOperation for ethereum
 */
RCT_REMAP_METHOD(isInstanceOfEthereumLikeOperation,isInstanceOfEthereumLikeOperationWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isInstanceOfEthereumLikeOperation])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::isInstanceOfEthereumLikeOperation", nil);
    }
}

/**
 *Same as asBitcoinLikeOperation for ripple
 *# asRippleLikeOperation(): Callback<RippleLikeOperation>;
 *Same as isInstanceOfBitcoinLikeOperation for ripple
 */
RCT_REMAP_METHOD(isInstanceOfRippleLikeOperation,isInstanceOfRippleLikeOperationWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isInstanceOfRippleLikeOperation])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::isInstanceOfRippleLikeOperation", nil);
    }
}

/**
 *Tells if the operation is complete
 *@return boolean
 */
RCT_REMAP_METHOD(isComplete,isCompleteWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isComplete])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::isComplete", nil);
    }
}

/**
 *Get type of wallet from which operation was issued
 *@return WalletType object
 */
RCT_REMAP_METHOD(getWalletType,getWalletTypeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl getWalletType])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperation::getWalletType", nil);
    }
}
@end
