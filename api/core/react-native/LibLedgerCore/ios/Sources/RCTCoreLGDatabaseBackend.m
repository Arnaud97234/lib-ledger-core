// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from database.djinni

#import "RCTCoreLGDatabaseBackend.h"


@implementation RCTCoreLGDatabaseBackend
//Export module
RCT_EXPORT_MODULE(RCTCoreLGDatabaseBackend)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGDatabaseBackend alloc] init];
    }
    return self;
}

/**
 *Set database's user name
 *@param username, string
 *@return DatabaseBackend object, databse with user name set
 */
RCT_REMAP_METHOD(setUsername,setUsername:(nonnull NSString *)username withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setUsername:username]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setUsername", nil);
    }
}

/**
 *Set database's password
 *@param password, string
 *@return DatabaseBackend object, database with password set
 */
RCT_REMAP_METHOD(setPassword,setPassword:(nonnull NSString *)pwd withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setPassword:pwd]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setPassword", nil);
    }
}

/**
 *Set database's host which storing database
 *@param host, string
 *@return DatabaseBackend object, database with host set
 */
RCT_REMAP_METHOD(setHost,setHost:(nonnull NSString *)host withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setHost:host]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setHost", nil);
    }
}

/**
 *Set database's host's address
 *@param hostAddr, string, host's address
 *@return DatabaseBackend object, database with host's address set
 */
RCT_REMAP_METHOD(setHostAddr,setHostAddr:(nonnull NSString *)hostAddr withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setHostAddr:hostAddr]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setHostAddr", nil);
    }
}

/**
 *Set database's port on which it connects to host
 *@param port, string
 *@return DatabaseBackend object, database with port set
 */
RCT_REMAP_METHOD(setPort,setPort:(nonnull NSString *)port withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setPort:port]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setPort", nil);
    }
}

/**
 *Set database's specific options
 *@param opts, string
 *@return DatabaseBackend object, database with options set
 */
RCT_REMAP_METHOD(setOptions,setOptions:(nonnull NSString *)opts withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setOptions:opts]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setOptions", nil);
    }
}

/**
 *Set database's mode (SSL) of security interaction of type databse/server
 *@param mode, string
 *@return DatabaseBackend object, database with mode set
 */
RCT_REMAP_METHOD(setSslMode,setSslMode:(nonnull NSString *)mode withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setSslMode:mode]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setSslMode", nil);
    }
}

/**
 *Set database's Kerberos name used to secure (authentication) user/databse interaction
 *@param name, string
 *@return DatabaseBackend object, database with Kerberos name set
 */
RCT_REMAP_METHOD(setKerberosName,setKerberosName:(nonnull NSString *)name withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setKerberosName:name]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setKerberosName", nil);
    }
}

/**TODO */
RCT_REMAP_METHOD(setService,setService:(nonnull NSString *)service withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setService:service]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setService", nil);
    }
}

RCT_REMAP_METHOD(setConnectionPoolSize,setConnectionPoolSize:(int32_t)size withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setConnectionPoolSize:size]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::setConnectionPoolSize", nil);
    }
}

RCT_REMAP_METHOD(enableQueryLogging,enableQueryLogging:(BOOL)enable withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl enableQueryLogging:enable]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::enableQueryLogging", nil);
    }
}

/**
 *Return database's name
 *@return string
 */
RCT_REMAP_METHOD(getUsername,getUsernameWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getUsername]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getUsername", nil);
    }
}

/**
 *Return database's password
 *@return string
 */
RCT_REMAP_METHOD(getPassword,getPasswordWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getPassword]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getPassword", nil);
    }
}

/**
 *Return database's host
 *@return string
 */
RCT_REMAP_METHOD(getHost,getHostWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getHost]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getHost", nil);
    }
}

/**
 *Return database's host's address
 *@return string
 */
RCT_REMAP_METHOD(getHostAddr,getHostAddrWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getHostAddr]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getHostAddr", nil);
    }
}

/**
 *Return database's port
 *@return string
 */
RCT_REMAP_METHOD(getPort,getPortWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getPort]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getPort", nil);
    }
}

/**
 *Return database's options
 *@return string
 */
RCT_REMAP_METHOD(getOptions,getOptionsWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getOptions]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getOptions", nil);
    }
}

/**
 *Return database's SSL mode
 *@return string
 */
RCT_REMAP_METHOD(getSslMode,getSslModeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getSslMode]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getSslMode", nil);
    }
}

/**
 *Return database's Kerberos name
 *@return string
 */
RCT_REMAP_METHOD(getKerberosName,getKerberosNameWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getKerberosName]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getKerberosName", nil);
    }
}

/**TODO */
RCT_REMAP_METHOD(getService,getServiceWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getService]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getService", nil);
    }
}

RCT_REMAP_METHOD(getConnectionPoolSize,getConnectionPoolSizeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl getConnectionPoolSize])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getConnectionPoolSize", nil);
    }
}

RCT_REMAP_METHOD(isLoggingEnabled,isLoggingEnabledWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isLoggingEnabled])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::isLoggingEnabled", nil);
    }
}

/**
 *Create an instance of SQLite3 database
 *@return DatabaseBackend object
 */
RCT_REMAP_METHOD(getSqlite3Backend,getSqlite3BackendWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[LGDatabaseBackend getSqlite3Backend]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getSqlite3Backend", nil);
    }
}

/**
 *Create an instance of PostgreSQL database
 *@return DatabaseBackend object
 */
RCT_REMAP_METHOD(getPostgreSQLBackend,getPostgreSQLBackendWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[LGDatabaseBackend getPostgreSQLBackend]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGDatabaseBackend::getPostgreSQLBackend", nil);
    }
}
@end
