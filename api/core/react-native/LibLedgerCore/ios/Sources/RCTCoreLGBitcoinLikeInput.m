// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from bitcoin_like_wallet.djinni

#import "RCTCoreLGBitcoinLikeInput.h"


@implementation RCTCoreLGBitcoinLikeInput
//Export module
RCT_EXPORT_MODULE(RCTCoreLGBitcoinLikeInput)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGBitcoinLikeInput alloc] init];
    }
    return self;
}

/**
 *Get address that spends the input
 *@return Optional String, address emmiting input
 */
RCT_REMAP_METHOD(getAddress,getAddressWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getAddress];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeInput::getAddress", nil);
    }
}

/**
 *Get amount of input
 *@return Optional Amount object, amount of input
 */
RCT_REMAP_METHOD(getValue,getValueWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getValue];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeInput::getValue", nil);
    }
}

/**
 *Check whether input
 *@return Boolean, true if input belongs to coinbase transaction (reward for mining a block)
 */
RCT_REMAP_METHOD(isCoinbase,isCoinbaseWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl isCoinbase];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeInput::isCoinbase", nil);
    }
}

/**
 *Stored data cointained in coinbase
 *@return Optional String
 */
RCT_REMAP_METHOD(getCoinbase,getCoinbaseWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getCoinbase];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeInput::getCoinbase", nil);
    }
}

/**
 *Get hash of previous transaction that generates that input
 *@return Optional String, hash of previous transaction (null if coinbase)
 */
RCT_REMAP_METHOD(getPreviousTxHash,getPreviousTxHashWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getPreviousTxHash];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeInput::getPreviousTxHash", nil);
    }
}

/**
 *Get output index, it identifies which UTXO from tht transaction to spend
 *@return Optional 32 bits integer, index of previous transaction
 */
RCT_REMAP_METHOD(getPreviousOutputIndex,getPreviousOutputIndexWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl getPreviousOutputIndex];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeInput::getPreviousOutputIndex", nil);
    }
}
@end
