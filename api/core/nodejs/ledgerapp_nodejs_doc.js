// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni

declare class NJSSecp256k1
{
    declare function computePubKey(privKey: Object, compress: boolean): Object;
    declare function sign(privKey: Object, data: Object): Object;
    declare function verify(data: Object, signature: Object, pubKey: Object): boolean;
    static declare function newInstance(): NJSSecp256k1;
}
declare class NJSNetworks
{
    static declare function bitcoin(): BitcoinLikeNetworkParameters;
}
declare class NJSHashAlgorithmHelper
{
    declare function ripemd160(data: Object): Object;
    declare function sha256(data: Object): Object;
    declare function keccak256(data: Object): Object;
}
declare class NJSEvent
{
    declare function getCode(): EventCode;
    declare function getPayload(): NJSDynamicObject;
    declare function isSticky(): boolean;
    declare function getStickyTag(): number;
    static declare function newInstance(code: EventCode, payload: NJSDynamicObject): NJSEvent;
}
declare class NJSEventReceiver
{
    declare function onEvent(event: NJSEvent);
}
declare class NJSEventBus
{
    declare function subscribe(context: NJSExecutionContext, receiver: NJSEventReceiver);
    declare function unsubscribe(receiver: NJSEventReceiver);
}
declare class NJSEventPublisher
{
    declare function getEventBus(): NJSEventBus;
    declare function post(event: NJSEvent);
    declare function postSticky(event: NJSEvent, tag: number);
    declare function relay(bus: NJSEventBus);
    static declare function newInstance(context: NJSExecutionContext): NJSEventPublisher;
}
declare class NJSSynchronizationStatus
{
}
declare class NJSDerivationPath
{
    /** Get the number of element in this path. */
    declare function getDepth(): number;
    /** Get the child num at the given index in the path. */
    declare function getChildNum(index: number): number;
    /**
     * Get the child num at the given index in the path. If the child num is hardened, returns it
     * without the hardened marker bit.
     */
    declare function getUnhardenedChildNum(index: number): number;
    /** Return true if the given index in the path is an hardened child num. */
    declare function isHardened(index: number): boolean;
    /** Serialize the given path to a human readable string like "44'/0'/0'/0/0" */
    declare function toString(): string;
    /**
     * Return a derivation path without the last element, e.g. the parent of "44'/0'/0'/0/0" is
     * "44'/0'/0'/0"
     */
    declare function getParent(): NJSDerivationPath;
    /** Return an array where which item is a child num of the path. */
    declare function toArray(): Array<number>;
    static declare function parse(path: string): NJSDerivationPath;
}
declare class NJSTrustIndicator
{
    declare function getTrustWeight(): number;
    declare function getTrustLevel(): TrustLevel;
    declare function getConflictingOperationUids(): Array<string>;
    declare function getOrigin(): string;
}
declare class NJSOperation
{
    declare function getUid(): string;
    declare function getAccountIndex(): number;
    declare function getOperationType(): OperationType;
    declare function getDate(): Date;
    declare function getSenders(): Array<string>;
    declare function getRecipients(): Array<string>;
    declare function getAmount(): NJSAmount;
    declare function getFees(): ?NJSAmount;
    declare function getPreferences(): NJSPreferences;
    declare function getTrust(): NJSTrustIndicator;
    declare function getBlockHeight(): ?number;
    declare function asBitcoinLikeOperation(): NJSBitcoinLikeOperation;
    /**
     *# asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
     *# asRippleLikeOperation(): Callback<RippleLikeEthereum>;
     */
    declare function isInstanceOfBitcoinLikeOperation(): boolean;
    declare function isInstanceOfEthereumLikeOperation(): boolean;
    declare function isInstanceOfRippleLikeOperation(): boolean;
    declare function isComplete(): boolean;
    declare function getWalletType(): WalletType;
}
declare class NJSQueryFilter
{
    static declare function accountEq(accountUid: string): NJSQueryFilter;
    static declare function accountNeq(accountUid: string): NJSQueryFilter;
    static declare function dateLte(time: Date): NJSQueryFilter;
    static declare function dateLt(time: Date): NJSQueryFilter;
    static declare function dateGt(time: Date): NJSQueryFilter;
    static declare function dateGte(time: Date): NJSQueryFilter;
    static declare function dateEq(time: Date): NJSQueryFilter;
    static declare function dateNeq(time: Date): NJSQueryFilter;
    static declare function containsRecipient(recipientAddress: string): NJSQueryFilter;
    static declare function containsSender(senderAddress: string): NJSQueryFilter;
    static declare function currencyEq(currencyName: string): NJSQueryFilter;
    static declare function operationUidEq(operationUid: string): NJSQueryFilter;
    static declare function operationUidNeq(operationUid: string): NJSQueryFilter;
    static declare function trustEq(trust: TrustLevel): NJSQueryFilter;
    static declare function trustNeq(trust: TrustLevel): NJSQueryFilter;
    static declare function feesEq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGt(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountEq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLt(amount: NJSAmount): NJSQueryFilter;
    static declare function blockHeightEq(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightNeq(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightGte(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightGt(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightLte(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightLt(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightIsNull(): NJSQueryFilter;
    static declare function operationTypeEq(operationType: OperationType): NJSQueryFilter;
    static declare function operationTypeNeq(operationType: OperationType): NJSQueryFilter;
    declare function op_and(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_and_not(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or_not(filter: NJSQueryFilter): NJSQueryFilter;
}
declare class NJSOperationQuery
{
    declare function addOrder(key: OperationOrderKey, descending: boolean): NJSOperationQuery;
    declare function filter(): NJSQueryFilter;
    declare function offset(from: number): NJSOperationQuery;
    declare function limit(count: number): NJSOperationQuery;
    declare function complete(): NJSOperationQuery;
    declare function partial(): NJSOperationQuery;
    declare function execute(callback: NJSOperationListCallback);
}
declare class NJSOperationListCallback
{
    declare function onCallback(result: ?Array<NJSOperation>, error: ?Error);
}
declare class NJSAccount
{
    declare function getIndex(): number;
    declare function queryOperations(): NJSOperationQuery;
    declare function getBalance(callback: NJSAmountCallback);
    declare function isSynchronizing(): boolean;
    declare function synchronize(): NJSEventBus;
    declare function getPreferences(): NJSPreferences;
    declare function getLogger(): NJSLogger;
    declare function getOperationPreferences(uid: string): NJSPreferences;
    /**
     * asBitcoinLikeAccount(): Callback<BitcoinLikeAccount>;
     * asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
     * asRippleLikeAccount(): Callback<RippleLikeAccount>;
     */
    declare function isInstanceOfBitcoinLikeAccount(): boolean;
    declare function isInstanceOfEthereumLikeAccount(): boolean;
    declare function isInstanceOfRippleLikeAccount(): boolean;
    declare function getFreshPublicAddresses(callback: NJSStringListCallback);
    declare function getWalletType(): WalletType;
    declare function getEventBus(): NJSEventBus;
    declare function startBlockchainObservation();
    declare function stopBlockchainObservation();
    declare function isObservingBlockchain(): boolean;
    declare function getLastBlock(callback: NJSBlockCallback);
}
declare class NJSAmountCallback
{
    declare function onCallback(result: ?NJSAmount, error: ?Error);
}
declare class NJSStringListCallback
{
    declare function onCallback(result: ?Array<string>, error: ?Error);
}
declare class NJSBlockCallback
{
    declare function onCallback(result: ?Block, error: ?Error);
}
declare class NJSWallet
{
    declare function getName(): string;
    declare function getAccount(index: number, callback: NJSAccountCallback);
    declare function getAccountCount(callback: NJSI32Callback);
    declare function getAccounts(offset: number, count: number, callback: NJSAccountListCallback);
    declare function getNextAccountIndex(callback: NJSI32Callback);
    declare function getEventBus(): NJSEventBus;
    declare function isSynchronizing(): boolean;
    declare function synchronize(): NJSEventBus;
    declare function getPreferences(): NJSPreferences;
    declare function getLogger(): NJSLogger;
    declare function getAccountPreferences(index: number): NJSPreferences;
    /**
     * asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
     * asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
     * asRippleLikeWallet(): Callback<RippleLikeWallet>;
     */
    declare function asBitcoinLikeWallet(): NJSBitcoinLikeWallet;
    declare function getCurrency(): Currency;
    declare function isInstanceOfBitcoinLikeWallet(): boolean;
    declare function isInstanceOfEthereumLikeWallet(): boolean;
    declare function isInstanceOfRippleLikeWallet(): boolean;
    declare function getWalletType(): WalletType;
    declare function getLastBlock(callback: NJSBlockCallback);
    declare function getAccountCreationInfo(accountIndex: number, callback: NJSAccountCreationInfoCallback);
    declare function getExtendedKeyAccountCreationInfo(accountIndex: number, callback: NJSExtendedKeyAccountCreationInfoCallback);
    declare function getNextAccountCreationInfo(callback: NJSAccountCreationInfoCallback);
    declare function getNextExtendedKeyAccountCreationInfo(callback: NJSExtendedKeyAccountCreationInfoCallback);
    declare function newAccountWithInfo(accountCreationInfo: AccountCreationInfo, callback: NJSAccountCallback);
    declare function newAccountWithExtendedKeyInfo(extendedKeyAccountCreationInfo: ExtendedKeyAccountCreationInfo, callback: NJSAccountCallback);
}
declare class NJSAccountCallback
{
    declare function onCallback(result: ?NJSAccount, error: ?Error);
}
declare class NJSI32Callback
{
    declare function onCallback(result: ?number, error: ?Error);
}
declare class NJSAccountListCallback
{
    declare function onCallback(result: ?Array<NJSAccount>, error: ?Error);
}
declare class NJSAccountCreationInfoCallback
{
    declare function onCallback(result: ?AccountCreationInfo, error: ?Error);
}
declare class NJSExtendedKeyAccountCreationInfoCallback
{
    declare function onCallback(result: ?ExtendedKeyAccountCreationInfo, error: ?Error);
}
declare class NJSDynamicArray
{
    declare function size(): number;
    declare function getString(index: number): ?string;
    declare function getInt(index: number): ?number;
    declare function getLong(index: number): ?number;
    declare function getDouble(index: number): ?number;
    declare function getData(index: number): ?Object;
    declare function getBoolean(index: number): ?boolean;
    declare function pushInt(value: number): NJSDynamicArray;
    declare function pushLong(value: number): NJSDynamicArray;
    declare function pushString(value: string): NJSDynamicArray;
    declare function pushDouble(value: number): NJSDynamicArray;
    declare function pushData(value: Object): NJSDynamicArray;
    declare function pushBoolean(value: boolean): NJSDynamicArray;
    declare function getObject(index: number): ?NJSDynamicObject;
    declare function getArray(index: number): ?NJSDynamicArray;
    declare function pushObject(value: NJSDynamicObject): NJSDynamicArray;
    declare function pushArray(value: NJSDynamicArray): NJSDynamicArray;
    declare function concat(array: NJSDynamicArray): NJSDynamicArray;
    declare function getType(index: number): ?DynamicType;
    declare function remove(index: number): boolean;
    declare function dump(): string;
    declare function serialize(): Object;
    declare function isReadOnly(): boolean;
    static declare function newInstance(): NJSDynamicArray;
    static declare function load(serialized: Object): ?NJSDynamicArray;
}
declare class NJSDynamicObject
{
    declare function isReadOnly(): boolean;
    declare function putString(key: string, value: string): NJSDynamicObject;
    declare function putInt(key: string, value: number): NJSDynamicObject;
    declare function putLong(key: string, value: number): NJSDynamicObject;
    declare function putDouble(key: string, value: number): NJSDynamicObject;
    declare function putData(key: string, value: Object): NJSDynamicObject;
    declare function putBoolean(key: string, value: boolean): NJSDynamicObject;
    declare function getString(key: string): ?string;
    declare function getInt(key: string): ?number;
    declare function getLong(key: string): ?number;
    declare function getDouble(key: string): ?number;
    declare function getData(key: string): ?Object;
    declare function getBoolean(key: string): ?boolean;
    declare function putObject(key: string, value: NJSDynamicObject): NJSDynamicObject;
    declare function putArray(key: string, value: NJSDynamicArray): NJSDynamicObject;
    declare function getObject(key: string): ?NJSDynamicObject;
    declare function getArray(key: string): ?NJSDynamicArray;
    declare function contains(key: string): boolean;
    declare function remove(key: string): boolean;
    declare function getKeys(): Array<string>;
    declare function getType(key: string): ?DynamicType;
    declare function dump(): string;
    declare function serialize(): Object;
    declare function size(): number;
    static declare function newInstance(): NJSDynamicObject;
    static declare function load(serialized: Object): ?NJSDynamicObject;
}
declare class NJSBlockchainExplorerEngines
{
}
declare class NJSBlockchainObserverEngines
{
}
declare class NJSKeychainEngines
{
}
declare class NJSSynchronizerEngines
{
}
declare class NJSSynchronizationEngines
{
}
declare class NJSConfigurationDefaults
{
}
declare class NJSConfiguration
{
}
declare class NJSPoolConfiguration
{
}
declare class NJSDatabaseBackend
{
    declare function setUsername(username: string): NJSDatabaseBackend;
    declare function setPassword(pwd: string): NJSDatabaseBackend;
    declare function setHost(host: string): NJSDatabaseBackend;
    declare function setHostAddr(hostAddr: string): NJSDatabaseBackend;
    declare function setPort(port: string): NJSDatabaseBackend;
    declare function setOptions(opts: string): NJSDatabaseBackend;
    declare function setSslMode(mode: string): NJSDatabaseBackend;
    declare function setKerberosName(name: string): NJSDatabaseBackend;
    declare function setService(service: string): NJSDatabaseBackend;
    declare function setConnectionPoolSize(size: number): NJSDatabaseBackend;
    declare function enableQueryLogging(enable: boolean): NJSDatabaseBackend;
    declare function getUsername(): string;
    declare function getPassword(): string;
    declare function getHost(): string;
    declare function getHostAddr(): string;
    declare function getPort(): string;
    declare function getOptions(): string;
    declare function getSslMode(): string;
    declare function getKerberosName(): string;
    declare function getService(): string;
    declare function getConnectionPoolSize(): number;
    declare function isLoggingEnabled(): boolean;
    static declare function getSqlite3Backend(): NJSDatabaseBackend;
    static declare function getPostgreSQLBackend(): NJSDatabaseBackend;
}
declare class NJSRandomNumberGenerator
{
    declare function getRandomBytes(size: number): Object;
    declare function getRandomInt(): number;
    declare function getRandomLong(): number;
    declare function getRandomByte(): number;
}
declare class NJSEthereumPublicKeyProvider
{
}
declare class NJSGetEthreumLikeWalletCallback
{
    declare function onSuccess(wallet: NJSEthereumLikeWallet, isCreated: boolean);
    declare function onError(error: Error);
}
declare class NJSEthereumLikeWallet
{
}
declare class NJSBitcoinLikeScriptChunk
{
    declare function isOperator(): boolean;
    declare function isPushedData(): boolean;
    declare function getOperator(): ?BitcoinLikeOperator;
    declare function getPushedData(): ?Object;
    declare function next(): NJSBitcoinLikeScriptChunk;
    declare function hasNext(): boolean;
}
declare class NJSBitcoinLikeScript
{
    declare function head(): NJSBitcoinLikeScriptChunk;
    declare function toString(): string;
    static declare function parse(data: Object): NJSBitcoinLikeScript;
}
/** Helper class for manipulating Bitcoin like addresses */
declare class NJSBitcoinLikeAddress
{
    /**
     * Gets the version of the address (P2SH or P2PKH)
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): BitcoinLikeNetworkParameters;
    /**
     * Serializes the hash160 into a Base58 encoded address (with checksum)
     * @return The Base58 serialization
     */
    declare function toBase58(): string;
    /**
     * Serializes the hash160 to a payment uri (i.e bitcoin:16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM)
     * @return A payment uri to this address
     * toPaymentUri(): string;
     * Checks if the given address is a P2SH address
     * @return True if the version byte matches the P2SH byte version of the address network parameters
     */
    declare function isP2SH(): boolean;
    /**
     * Checks if the given address is a P2PKH address
     * @return True if the version byte matches the P2PKH byte version of the address network parameters
     */
    declare function isP2PKH(): boolean;
    /**
     * Gets an optional derivation path (if the address comes from an extended public key)
     * @return The derivation path of the address
     */
    declare function getDerivationPath(): ?string;
    /**
     * Deserializes the given address (note that this function will throw an exception wether the address doesn't belong to
     * the given network parameters, or if the address contains invalid Base58 characters or if the checksum is invalid).
     * @return A BitcoinLikeAddress
     */
    static declare function fromBase58(params: BitcoinLikeNetworkParameters, address: string): NJSBitcoinLikeAddress;
    /**
     * Check if the given address is valid
     * @return true if the address is valid, false otherwise
     */
    static declare function isAddressValid(params: BitcoinLikeNetworkParameters, address: string): boolean;
}
declare class NJSBitcoinLikeExtendedPublicKey
{
    declare function derive(path: string): NJSBitcoinLikeAddress;
    declare function toBase58(): string;
    declare function getRootPath(): string;
    static declare function fromBase58(params: BitcoinLikeNetworkParameters, address: string, path: ?string): NJSBitcoinLikeExtendedPublicKey;
}
declare class NJSAmount
{
    declare function toBigInt(): NJSBigInt;
    declare function getCurrency(): Currency;
    declare function getUnit(): CurrencyUnit;
    declare function toUnit(unit: CurrencyUnit): NJSAmount;
    declare function toMagnitude(magnitude: number): NJSAmount;
    declare function toString(): string;
    declare function toLong(): number;
    declare function toDouble(): number;
    declare function format(locale: Locale, rules: ?FormatRules): string;
    static declare function fromHex(hex: string): NJSAmount;
    static declare function fromLong(value: number): NJSAmount;
}
/**
 * Interface for accessing and modifying custom preferences. Preferences are key - value data which will be persisted to
 * the filesystem. They can be local or stored with the Ledger API backend (encrypted by a user secret). This can be used to
 * attach application data to the libledger-core modules (i.e. a wallet pool, a wallet, an account, an operation). This interface
 * is highly inspired by Android SharedPreferences.
 */
declare class NJSPreferences
{
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getString(key: string, fallbackValue: string): string;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getInt(key: string, fallbackValue: number): number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getLong(key: string, fallbackValue: number): number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getBoolean(key: string, fallbackValue: boolean): boolean;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getStringArray(key: string, fallbackValue: Array<string>): Array<string>;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getData(key: string, fallbackValue: Object): Object;
    /**
     * Checks whether the Preferences contains the given key.
     * @return true the preferences contains the key, false otherwise.
     */
    declare function contains(key: string): boolean;
    /**
     * Get a preferences editor in order to add/modify/remove data.
     * @return An interface for editting preferences.
     */
    declare function edit(): NJSPreferencesEditor;
}
/** Interface for editting Preferences. All changes to the editor are persisted to the disk only when comitted. */
declare class NJSPreferencesEditor
{
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putString(key: string, value: string): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putInt(key: string, value: number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putLong(key: string, value: number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putBoolean(key: string, value: boolean): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putStringArray(key: string, value: Array<string>): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putData(key: string, value: Object): NJSPreferencesEditor;
    /**
     * Removes the data associated with the given key.
     * @param key The key to remove from the Preferences
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function remove(key: string): NJSPreferencesEditor;
    /** Persists the changes to the Preferences. */
    declare function commit();
}
declare class NJSBitcoinLikeWalletConfiguration
{
}
declare class NJSBitcoinLikeInput
{
    /** Returns the address of the input (if an address can be computed) */
    declare function getAddress(): ?string;
    /**
     * Returns the public associated with the address. This value can be NULL if you are building a transaction with an
     * address which does not belong to your wallet.
     */
    declare function getPublicKeys(): Array<Object>;
    /** Returns the derivation path of this input if the address is owned by the wallet */
    declare function getDerivationPath(): Array<NJSDerivationPath>;
    /**
     * Returns the value of the amount. Depending on the backend this value may not exist if the input is not owned by
     * the wallet.
     */
    declare function getValue(): ?NJSAmount;
    /** Return true if the input is a coinbase input */
    declare function isCoinbase(): boolean;
    /** Get coinbase input data */
    declare function getCoinbase(): ?string;
    /**
     * Get the transaction hash of the output spent by this input. The result can be NULL if the output is not owned by
     * the wallet
     */
    declare function getPreviousTxHash(): ?string;
    /**
     * Get the index at which the output is located in the transaction output spent by this input. The result can be
     * NULL if the input does not belong to the wallet
     */
    declare function getPreviousOutputIndex(): ?number;
    /**
     * Retrieve the output spent by this input. Depending on the implementation this method may
     * use a lock to fetch data from a database. Therefore it may have poor performance, use with
     * caution.
     * @return The output spent by this input.
     */
    declare function getPreviousOuput(): NJSBitcoinLikeOutput;
    /** Get ScriptSig of this input. The scriptsig is the first half of a script necessary to spend a previous output. */
    declare function getScriptSig(): Object;
    /** Parse the script sig to a [[BitcoinLikeScript]] */
    declare function parseScriptSig(): NJSBitcoinLikeScript;
    /**
     * Set the ScriptS to the given value
     * @param scriptSig The ScriptSig to use for this input
     */
    declare function setScriptSig(scriptSig: Object);
    /** Push data to the end of the current ScriptSig */
    declare function pushToScriptSig(data: Object);
    /** Set the sequence number of this input */
    declare function setSequence(sequence: number);
    /** Get the sequence number of this input */
    declare function getSequence(): number;
    declare function getPreviousTransaction(): ?Object;
    /** Easy way to set the P2PKH script signature. Shorthand for input.pushToScriptSig(input.getPublicKeys()[0], signature) */
    declare function setP2PKHSigScript(signature: Object);
}
declare class NJSBitcoinLikeOutput
{
    declare function getTransactionHash(): string;
    declare function getOutputIndex(): number;
    declare function getValue(): NJSAmount;
    declare function getScript(): Object;
    declare function parseScript(): NJSBitcoinLikeScript;
    declare function getAddress(): ?string;
}
declare class NJSBitcoinLikeBlock
{
    declare function getHash(): string;
    declare function getHeight(): number;
    declare function getTime(): Date;
}
declare class NJSBitcoinLikeTransaction
{
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get the input of the transaction */
    declare function getInputs(): Array<NJSBitcoinLikeInput>;
    /** Get the output of the transaction */
    declare function getOutputs(): Array<NJSBitcoinLikeOutput>;
    /** Get the block in which the transaction is inserted if the transaction is confirmed. */
    declare function getBlock(): ?NJSBitcoinLikeBlock;
    /** Get the lock time of the transaction. */
    declare function getLockTime(): number;
    /** Get the amount of fees of the transaction. */
    declare function getFees(): NJSAmount;
    /**
     * Get the time when the transaction was issued or the time of the block including
     * this transaction
     */
    declare function getTime(): Date;
    /** Get the timestamps serialized in the raw transaction if the underlying currency handles it. */
    declare function getTimestamp(): ?Date;
    /** Serialize the transaction to its raw format. */
    declare function serialize(): Object;
    /** Get the witness if the underlying transaction is a segwit transaction. */
    declare function getWitness(): ?Object;
    /**
     * Estimate the size of the raw transaction in bytes. This method returns a minimum estimated size and a maximum estimated
     * size.
     */
    declare function getEstimatedSize(): EstimatedSize;
}
declare class NJSBitcoinLikeOperation
{
    declare function getTransaction(): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeHelper
{
    static declare function scriptToOutput(script: Object, amount: NJSAmount): NJSBitcoinLikeOutput;
    static declare function addressToOutput(address: string, amount: NJSAmount): NJSBitcoinLikeOutput;
    static declare function serializeTransaction(preparedTransaction: BitcoinLikePreparedTransaction): Object;
    static declare function parseTransaction(transaction: Object): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeTransactionBuilder
{
    /**
     * Add the given input to the final transaction.
     * @param transactionhash The hash of the transaction in where the UTXO can be located.
     * @params index Index of the UTXO in the previous transaction
     * @params sequence Sequence number to add at the end of the input serialization. This can be used for RBF transaction
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addInput(transactionHash: string, index: number, sequence: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Add the given output to the final transaction
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addOutput(amount: NJSAmount, script: NJSBitcoinLikeScript): NJSBitcoinLikeTransactionBuilder;
    /**
     * If needed the transaction will send its change to the given path. It is possible to add multiple change path.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addChangePath(path: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Exclude UTXO from the coin selection (alias UTXO picking). You can call this method multiple times to exclude multiple
     * UTXO.
     * @param transactionHash The hash of the transaction in which this UTXO can be found.
     * @param outputIndex The position of the output in the previous transaction,
     * @return A reference on the same builder in order to chain calls.
     */
    declare function excludeUtxo(transactionHash: string, outputIndex: number): NJSBitcoinLikeTransactionBuilder;
    /** @return A reference on the same builder in order to chain calls. */
    declare function setNumberOfChangeAddresses(count: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the maximum amount per change output. By default there is no max amount.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setMaxAmountOnChange(amount: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the minimum amount per change output. By default this value is the dust value of the currency.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setMinAmountOnChange(amount: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the UTXO picking strategy (see [[BitcoinLikePickingStrategy]]).
     * @param strategy The strategy to adopt in order to select which input to use in the transaction.
     * @param sequence The sequence value serialized at the end of the raw transaction. If you don't know what to put here
     * just use 0xFFFFFF
     * @return A reference on the same builder in order to chain calls.
     */
    declare function pickInputs(strategy: BitcoinLikePickingStrategy, sequence: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function sendToAddress(amount: NJSAmount, address: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the amount of fees per byte (of the raw transaction).
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setFeesPerByte(fees: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /** Build a transaction from the given builder parameters. */
    declare function build(callback: NJSBitcoinLikeTransactionCallback);
    /**
     * Creates a clone of this builder.
     * @return A copy of the current builder instance.
     */
    declare function clone(): NJSBitcoinLikeTransactionBuilder;
    /** Reset the current instance to its initial state */
    declare function reset();
}
declare class NJSBitcoinLikeTransactionCallback
{
    declare function onCallback(result: ?NJSBitcoinLikeTransaction, error: ?Error);
}
declare class NJSBitcoinLikeAccount
{
    declare function getUTXO(from: number, to: number, callback: NJSBitcoinLikeOutputListCallback);
    declare function getUTXOCount(callback: NJSI32Callback);
    declare function broadcastRawTransaction(transaction: Object, callback: NJSStringCallback);
    declare function broadcastTransaction(transaction: NJSBitcoinLikeTransaction, callback: NJSStringCallback);
    declare function buildTransaction(): NJSBitcoinLikeTransactionBuilder;
}
declare class NJSBitcoinLikeOutputListCallback
{
    declare function onCallback(result: ?Array<NJSBitcoinLikeOutput>, error: ?Error);
}
declare class NJSStringCallback
{
    declare function onCallback(result: ?string, error: ?Error);
}
declare class NJSBitcoinLikeWallet
{
}
declare class NJSWalletPool
{
    declare function getLogger(): NJSLogger;
    declare function getName(): string;
    declare function getPreferences(): NJSPreferences;
    declare function getWalletCount(callback: NJSI32Callback);
    declare function getWallets(from: number, size: number, callback: NJSWalletListCallback);
    declare function getWallet(name: string, callback: NJSWalletCallback);
    declare function createWallet(name: string, currency: Currency, configuration: NJSDynamicObject, callback: NJSWalletCallback);
    declare function getCurrencies(callback: NJSCurrencyListCallback);
    declare function getCurrency(name: string, callback: NJSCurrencyCallback);
    declare function getLastBlock(currencyName: string, callback: NJSBlockCallback);
    declare function getEventBus(): NJSEventBus;
}
declare class NJSWalletListCallback
{
    declare function onCallback(result: ?Array<NJSWallet>, error: ?Error);
}
declare class NJSWalletCallback
{
    declare function onCallback(result: ?NJSWallet, error: ?Error);
}
declare class NJSCurrencyListCallback
{
    declare function onCallback(result: ?Array<Currency>, error: ?Error);
}
declare class NJSCurrencyCallback
{
    declare function onCallback(result: ?Currency, error: ?Error);
}
declare class NJSWalletPoolBuilder
{
    declare function setHttpClient(client: NJSHttpClient): NJSWalletPoolBuilder;
    declare function setWebsocketClient(client: NJSWebSocketClient): NJSWalletPoolBuilder;
    declare function setPathResolver(pathResolver: NJSPathResolver): NJSWalletPoolBuilder;
    declare function setLogPrinter(printer: NJSLogPrinter): NJSWalletPoolBuilder;
    declare function setThreadDispatcher(dispatcher: NJSThreadDispatcher): NJSWalletPoolBuilder;
    declare function setName(name: string): NJSWalletPoolBuilder;
    declare function setPassword(password: string): NJSWalletPoolBuilder;
    declare function setRandomNumberGenerator(rng: NJSRandomNumberGenerator): NJSWalletPoolBuilder;
    declare function setDatabaseBackend(backend: NJSDatabaseBackend): NJSWalletPoolBuilder;
    declare function setConfiguration(configuration: NJSDynamicObject): NJSWalletPoolBuilder;
    declare function build(listener: NJSWalletPoolCallback);
    static declare function createInstance(): NJSWalletPoolBuilder;
}
declare class NJSWalletPoolCallback
{
    declare function onCallback(result: ?NJSWalletPool, error: ?Error);
}
declare class NJSWebSocketConnection
{
    declare function onConnect(connectionId: number);
    declare function onClose();
    declare function onMessage(data: string);
    declare function onError(code: ErrorCode, message: string);
    declare function getConnectionId(): number;
}
declare class NJSWebSocketClient
{
    declare function connect(url: string, connection: NJSWebSocketConnection);
    declare function send(connection: NJSWebSocketConnection, data: string);
    declare function disconnect(connection: NJSWebSocketConnection);
}
declare class NJSHttpUrlConnection
{
    /**
     * Gets the HTTP response status code
     * @return The HTTP response status code
     */
    declare function getStatusCode(): number;
    /**
     * Gets the HTTP response status text
     * @return The HTTP response status text
     */
    declare function getStatusText(): string;
    /**
     * Gets the HTTP response headers
     * @return The HTTP response headers
     */
    declare function getHeaders(): Map<string, string>;
    /**
     * Reads available HTTP response body. This method will be called multiple times until it returns a empty bytes array.
     * @returns A chunk of the body data wrapped into a HttpReadBodyResult (for error management)
     */
    declare function readBody(): HttpReadBodyResult;
}
declare class NJSHttpRequest
{
    declare function getMethod(): HttpMethod;
    declare function getHeaders(): Map<string, string>;
    declare function getBody(): Object;
    declare function getUrl(): string;
    declare function complete(response: ?NJSHttpUrlConnection, error: ?Error);
}
declare class NJSHttpClient
{
    declare function execute(request: NJSHttpRequest);
}
/** Immutable class representing a potentially very long number */
declare class NJSBigInt
{
    /**
     * Adds two BigInt and returns a new BigInt with the result.
     * @params i Value to be added to this BigInt
     * @return The result of this + i
     */
    declare function add(i: NJSBigInt): NJSBigInt;
    /**
     * Subtracts two BigInt and returns a new BigInt with result.
     * @params i Value to be subtracted to this BigInt
     * @return The result of this - i
     */
    declare function subtract(i: NJSBigInt): NJSBigInt;
    /**
     * Multiplies two BigInt and returns a new BigInt with result.
     * @params i Value to be multiplied by this BigInt
     * @return The result of this * i
     */
    declare function multiply(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result.
     * @params i Value by which this BigInt will be divided
     * @return The result of this / i
     */
    declare function divide(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
     * @params i Value by which this BigInteger is to be divided, and the remainder computed
     * @return A tuple of [this / i, this % i]
     */
    declare function divideAndRemainder(i: NJSBigInt): Array<NJSBigInt>;
    /**
     * Raises this BigInt with an interger value.
     * @params i The exponent to which thi BigInt is raised
     * @return The result of this ^ exponent
     */
    declare function pow(exponent: number): NJSBigInt;
    /**
     * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
     * @params precision The power of ten by wich this BigInt is divided
     * @params decimalSeparator The separator to use between the integer part and the decimal part
     * @params thousandSeparator The separator to use between each group of thousand units
     * @return The BigInt formatted as a decimal string
     */
    declare function toDecimalString(precision: number, decimalSeparator: string, thousandSeparator: string): string;
    /**
     * Formats this BigInt to the interger representation of its internal value.
     * @params radix The radix of the number representation in which to format (right now 10 or 16)
     */
    declare function toString(radix: number): string;
    /**
     * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
     * will be meaningless.
     * @return The int representation of this BigInt
     */
    declare function intValue(): number;
    /**
     * Compares two BigInt together.
     * @param i The value to compare with this BigInt
     * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
     */
    declare function compare(i: NJSBigInt): number;
    /**
     * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
     * are ignored (e.g. "1ledger000" will be equal to "1000")
     * @param s The string with the decimal representation of the BigInt
     * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
     * @params decimalSeparator The decimal separator used by this string representation
     * @return The created BigInt
     */
    static declare function fromDecimalString(s: string, precision: number, decimalSeparator: string): NJSBigInt;
    /**
     * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
     * @param s The string to parse
     * @param radix The radix of the number representation (right now 10 or 16)
     * @return The created BigInt
     */
    static declare function fromIntegerString(s: string, radix: number): NJSBigInt;
    /**
     * Creates a BigInt from a int64 value
     * @param l The value to convert
     * @return The created BigInt
     */
    static declare function fromLong(l: number): NJSBigInt;
}
/**
 * Module used to resolve file paths. libledger-core has its own iternal representation of the file system that may not
 * be adapted for the runtime platform. All path given to the PathResolver are absolute.
 */
declare class NJSPathResolver
{
    /**
     * Resolves the path for a SQLite database file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveDatabasePath(path: string): string;
    /**
     * Resolves the path of a single log file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveLogFilePath(path: string): string;
    /**
     * Resolves the path for a json file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolvePreferencesPath(path: string): string;
}
declare class NJSRunnable
{
    declare function run();
}
declare class NJSLock
{
    declare function lock();
    declare function tryLock(): boolean;
    declare function unlock();
}
declare class NJSExecutionContext
{
    /** */
    declare function execute(runnable: NJSRunnable);
    declare function delay(runnable: NJSRunnable, millis: number);
}
declare class NJSThreadDispatcher
{
    declare function getSerialExecutionContext(name: string): NJSExecutionContext;
    declare function getThreadPoolExecutionContext(name: string): NJSExecutionContext;
    declare function getMainExecutionContext(): NJSExecutionContext;
    declare function newLock(): NJSLock;
}
declare class NJSLogPrinter
{
    declare function printError(message: string);
    declare function printInfo(message: string);
    declare function printDebug(message: string);
    declare function printWarning(message: string);
    declare function printApdu(message: string);
    declare function printCriticalError(message: string);
    declare function getContext(): NJSExecutionContext;
}
declare class NJSLogger
{
    declare function d(tag: string, message: string);
    declare function i(tag: string, message: string);
    declare function e(tag: string, message: string);
    declare function w(tag: string, message: string);
    declare function c(tag: string, message: string);
}
declare class NJSLedgerCore
{
    /**
     * Gets the version of the library as a human readable string.
     * @return The version of the library (e.g. '1.0.1')
     */
    static declare function getStringVersion(): string;
    /**
     * Get the integer version of the Library
     * @return The integer version of the library
     */
    static declare function getIntVersion(): number;
}
