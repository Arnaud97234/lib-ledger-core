// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni

declare class NJSSecp256k1
{
    declare function computePubKey(Object: privKey, Boolean: compress): Object;
    declare function sign(Object: privKey, Object: data): Object;
    declare function verify(Object: data, Object: signature, Object: pubKey): Boolean;
    static declare function newInstance(): NJSSecp256k1;
}
declare class NJSNetworks
{
    static declare function bitcoin(): BitcoinLikeNetworkParameters;
}
declare class NJSHashAlgorithmHelper
{
    declare function ripemd160(Object: data): Object;
    declare function sha256(Object: data): Object;
    declare function keccak256(Object: data): Object;
}
declare class NJSEvent
{
    declare function getCode(): EventCode;
    declare function getPayload(): NJSDynamicObject;
    declare function isSticky(): Boolean;
    declare function getStickyTag(): Int32;
    static declare function newInstance(EventCode: code, NJSDynamicObject: payload): NJSEvent;
}
declare class NJSEventReceiver
{
    declare function onEvent(NJSEvent: event)
}
declare class NJSEventBus
{
    declare function subscribe(NJSExecutionContext: context, NJSEventReceiver: receiver)
    declare function unsubscribe(NJSEventReceiver: receiver)
}
declare class NJSEventPublisher
{
    declare function getEventBus(): NJSEventBus;
    declare function post(NJSEvent: event)
    declare function postSticky(NJSEvent: event, Int32: tag)
    declare function relay(NJSEventBus: bus)
    static declare function newInstance(NJSExecutionContext: context): NJSEventPublisher;
}
declare class NJSSynchronizationStatus
{
}
declare class NJSTrustIndicator
{
    declare function getTrustWeight(): Int32;
    declare function getTrustLevel(): TrustLevel;
    declare function getConflictingOperationUids(): Array;
    declare function getOrigin(): String;
}
declare class NJSOperation
{
    declare function getUid(): String;
    declare function getAccountIndex(): Int32;
    declare function getOperationType(): OperationType;
    declare function getDate(): Date;
    declare function getSenders(): Array;
    declare function getRecipients(): Array;
    declare function getAmount(): NJSAmount;
    declare function getFees(): NJSAmount;
    declare function getPreferences(): NJSPreferences;
    declare function getTrust(): NJSTrustIndicator;
    declare function getBlockHeight(): MaybeLocal;
    declare function asBitcoinLikeOperation(): NJSBitcoinLikeOperation;
    /**
     *# asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
     *# asRippleLikeOperation(): Callback<RippleLikeEthereum>;
     */
    declare function isInstanceOfBitcoinLikeOperation(): Boolean;
    declare function isInstanceOfEthereumLikeOperation(): Boolean;
    declare function isInstanceOfRippleLikeOperation(): Boolean;
    declare function isComplete(): Boolean;
    declare function getWalletType(): WalletType;
}
declare class NJSQueryFilter
{
    static declare function accountEq(String: accountUid): NJSQueryFilter;
    static declare function accountNeq(String: accountUid): NJSQueryFilter;
    static declare function dateLte(Date: time): NJSQueryFilter;
    static declare function dateLt(Date: time): NJSQueryFilter;
    static declare function dateGt(Date: time): NJSQueryFilter;
    static declare function dateGte(Date: time): NJSQueryFilter;
    static declare function dateEq(Date: time): NJSQueryFilter;
    static declare function dateNeq(Date: time): NJSQueryFilter;
    static declare function containsRecipient(String: recipientAddress): NJSQueryFilter;
    static declare function containsSender(String: senderAddress): NJSQueryFilter;
    static declare function currencyEq(String: currencyName): NJSQueryFilter;
    static declare function operationUidEq(String: operationUid): NJSQueryFilter;
    static declare function operationUidNeq(String: operationUid): NJSQueryFilter;
    static declare function trustEq(TrustLevel: trust): NJSQueryFilter;
    static declare function trustNeq(TrustLevel: trust): NJSQueryFilter;
    static declare function feesEq(NJSAmount: amount): NJSQueryFilter;
    static declare function feesNeq(NJSAmount: amount): NJSQueryFilter;
    static declare function feesGte(NJSAmount: amount): NJSQueryFilter;
    static declare function feesGt(NJSAmount: amount): NJSQueryFilter;
    static declare function feesLte(NJSAmount: amount): NJSQueryFilter;
    static declare function feesLt(NJSAmount: amount): NJSQueryFilter;
    static declare function amountEq(NJSAmount: amount): NJSQueryFilter;
    static declare function amountNeq(NJSAmount: amount): NJSQueryFilter;
    static declare function amountGte(NJSAmount: amount): NJSQueryFilter;
    static declare function amountGt(NJSAmount: amount): NJSQueryFilter;
    static declare function amountLte(NJSAmount: amount): NJSQueryFilter;
    static declare function amountLt(NJSAmount: amount): NJSQueryFilter;
    static declare function blockHeightEq(Number: blockHeight): NJSQueryFilter;
    static declare function blockHeightNeq(Number: blockHeight): NJSQueryFilter;
    static declare function blockHeightGte(Number: blockHeight): NJSQueryFilter;
    static declare function blockHeightGt(Number: blockHeight): NJSQueryFilter;
    static declare function blockHeightLte(Number: blockHeight): NJSQueryFilter;
    static declare function blockHeightLt(Number: blockHeight): NJSQueryFilter;
    static declare function blockHeightIsNull(): NJSQueryFilter;
    static declare function operationTypeEq(OperationType: operationType): NJSQueryFilter;
    static declare function operationTypeNeq(OperationType: operationType): NJSQueryFilter;
    declare function op_and(NJSQueryFilter: filter): NJSQueryFilter;
    declare function op_or(NJSQueryFilter: filter): NJSQueryFilter;
    declare function op_and_not(NJSQueryFilter: filter): NJSQueryFilter;
    declare function op_or_not(NJSQueryFilter: filter): NJSQueryFilter;
}
declare class NJSOperationQuery
{
    declare function addOrder(OperationOrderKey: key, Boolean: descending): NJSOperationQuery;
    declare function filter(): NJSQueryFilter;
    declare function offset(Number: from): NJSOperationQuery;
    declare function limit(Number: count): NJSOperationQuery;
    declare function complete(): NJSOperationQuery;
    declare function partial(): NJSOperationQuery;
    declare function execute(NJSOperationListCallback: callback)
}
declare class NJSOperationListCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSAccount
{
    declare function getIndex(): Int32;
    declare function queryOperations(): NJSOperationQuery;
    declare function getBalance(NJSAmountCallback: callback)
    declare function isSynchronizing(): Boolean;
    declare function synchronize(): NJSEventBus;
    declare function getPreferences(): NJSPreferences;
    declare function getLogger(): NJSLogger;
    declare function getOperationPreferences(String: uid): NJSPreferences;
    /**
     * asBitcoinLikeAccount(): Callback<BitcoinLikeAccount>;
     * asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
     * asRippleLikeAccount(): Callback<RippleLikeAccount>;
     */
    declare function isInstanceOfBitcoinLikeAccount(): Boolean;
    declare function isInstanceOfEthereumLikeAccount(): Boolean;
    declare function isInstanceOfRippleLikeAccount(): Boolean;
    declare function getFreshPublicAddresses(NJSStringListCallback: callback)
    declare function getWalletType(): WalletType;
    declare function getEventBus(): NJSEventBus;
    declare function startBlockchainObservation()
    declare function stopBlockchainObservation()
    declare function isObservingBlockchain(): Boolean;
    declare function getLastBlock(NJSBlockCallback: callback)
    declare function computeFees(NJSAmount: amount, Int32: priority, Array: recipients, Array: data, NJSAmountCallback: callback)
}
declare class NJSAmountCallback
{
    declare function onCallback(NJSAmount: result, MaybeLocal: error)
}
declare class NJSStringListCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSBlockCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSWallet
{
    declare function getName(): String;
    declare function getAccount(Int32: index, NJSAccountCallback: callback)
    declare function getAccountCount(NJSI32Callback: callback)
    declare function getAccounts(Int32: offset, Int32: count, NJSAccountListCallback: callback)
    declare function getNextAccountIndex(NJSI32Callback: callback)
    declare function getEventBus(): NJSEventBus;
    declare function isSynchronizing(): Boolean;
    declare function synchronize(): NJSEventBus;
    declare function getPreferences(): NJSPreferences;
    declare function getLogger(): NJSLogger;
    declare function getAccountPreferences(Int32: index): NJSPreferences;
    /**
     * asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
     * asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
     * asRippleLikeWallet(): Callback<RippleLikeWallet>;
     */
    declare function asBitcoinLikeWallet(): NJSBitcoinLikeWallet;
    declare function getCurrency(): Currency;
    declare function isInstanceOfBitcoinLikeWallet(): Boolean;
    declare function isInstanceOfEthereumLikeWallet(): Boolean;
    declare function isInstanceOfRippleLikeWallet(): Boolean;
    declare function getWalletType(): WalletType;
    declare function getLastBlock(NJSBlockCallback: callback)
    declare function getAccountCreationInfo(Int32: accountIndex, NJSAccountCreationInfoCallback: callback)
    declare function getExtendedKeyAccountCreationInfo(Int32: accountIndex, NJSExtendedKeyAccountCreationInfoCallback: callback)
    declare function getNextAccountCreationInfo(NJSAccountCreationInfoCallback: callback)
    declare function getNextExtendedKeyAccountCreationInfo(NJSExtendedKeyAccountCreationInfoCallback: callback)
    declare function newAccountWithInfo(AccountCreationInfo: accountCreationInfo, NJSAccountCallback: callback)
    declare function newAccountWithExtendedKeyInfo(ExtendedKeyAccountCreationInfo: extendedKeyAccountCreationInfo, NJSAccountCallback: callback)
}
declare class NJSAccountCallback
{
    declare function onCallback(NJSAccount: result, MaybeLocal: error)
}
declare class NJSI32Callback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSAccountListCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSAccountCreationInfoCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSExtendedKeyAccountCreationInfoCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSDynamicArray
{
    declare function size(): Number;
    declare function getString(Number: index): MaybeLocal;
    declare function getInt(Number: index): MaybeLocal;
    declare function getLong(Number: index): MaybeLocal;
    declare function getDouble(Number: index): MaybeLocal;
    declare function getData(Number: index): MaybeLocal;
    declare function getBoolean(Number: index): MaybeLocal;
    declare function pushInt(Int32: value): NJSDynamicArray;
    declare function pushLong(Number: value): NJSDynamicArray;
    declare function pushString(String: value): NJSDynamicArray;
    declare function pushDouble(Number: value): NJSDynamicArray;
    declare function pushData(Object: value): NJSDynamicArray;
    declare function pushBoolean(Boolean: value): NJSDynamicArray;
    declare function getObject(Number: index): NJSDynamicObject;
    declare function getArray(Number: index): NJSDynamicArray;
    declare function pushObject(NJSDynamicObject: value): NJSDynamicArray;
    declare function pushArray(NJSDynamicArray: value): NJSDynamicArray;
    declare function concat(NJSDynamicArray: array): NJSDynamicArray;
    declare function getType(Number: index): MaybeLocal;
    declare function remove(Number: index): Boolean;
    declare function dump(): String;
    declare function serialize(): Object;
    declare function isReadOnly(): Boolean;
    static declare function newInstance(): NJSDynamicArray;
    static declare function load(Object: serialized): NJSDynamicArray;
}
declare class NJSDynamicObject
{
    declare function isReadOnly(): Boolean;
    declare function putString(String: key, String: value): NJSDynamicObject;
    declare function putInt(String: key, Int32: value): NJSDynamicObject;
    declare function putLong(String: key, Number: value): NJSDynamicObject;
    declare function putDouble(String: key, Number: value): NJSDynamicObject;
    declare function putData(String: key, Object: value): NJSDynamicObject;
    declare function putBoolean(String: key, Boolean: value): NJSDynamicObject;
    declare function getString(String: key): MaybeLocal;
    declare function getInt(String: key): MaybeLocal;
    declare function getLong(String: key): MaybeLocal;
    declare function getDouble(String: key): MaybeLocal;
    declare function getData(String: key): MaybeLocal;
    declare function getBoolean(String: key): MaybeLocal;
    declare function putObject(String: key, NJSDynamicObject: value): NJSDynamicObject;
    declare function putArray(String: key, NJSDynamicArray: value): NJSDynamicObject;
    declare function getObject(String: key): NJSDynamicObject;
    declare function getArray(String: key): NJSDynamicArray;
    declare function contains(String: key): Boolean;
    declare function remove(String: key): Boolean;
    declare function getKeys(): Array;
    declare function getType(String: key): MaybeLocal;
    declare function dump(): String;
    declare function serialize(): Object;
    declare function size(): Number;
    static declare function newInstance(): NJSDynamicObject;
    static declare function load(Object: serialized): NJSDynamicObject;
}
declare class NJSBlockchainExplorerEngines
{
}
declare class NJSBlockchainObserverEngines
{
}
declare class NJSKeychainEngines
{
}
declare class NJSSynchronizerEngines
{
}
declare class NJSSynchronizationEngines
{
}
declare class NJSConfigurationDefaults
{
}
declare class NJSConfiguration
{
}
declare class NJSPoolConfiguration
{
}
declare class NJSDatabaseBackend
{
    declare function setUsername(String: username): NJSDatabaseBackend;
    declare function setPassword(String: pwd): NJSDatabaseBackend;
    declare function setHost(String: host): NJSDatabaseBackend;
    declare function setHostAddr(String: hostAddr): NJSDatabaseBackend;
    declare function setPort(String: port): NJSDatabaseBackend;
    declare function setOptions(String: opts): NJSDatabaseBackend;
    declare function setSslMode(String: mode): NJSDatabaseBackend;
    declare function setKerberosName(String: name): NJSDatabaseBackend;
    declare function setService(String: service): NJSDatabaseBackend;
    declare function setConnectionPoolSize(Int32: size): NJSDatabaseBackend;
    declare function enableQueryLogging(Boolean: enable): NJSDatabaseBackend;
    declare function getUsername(): String;
    declare function getPassword(): String;
    declare function getHost(): String;
    declare function getHostAddr(): String;
    declare function getPort(): String;
    declare function getOptions(): String;
    declare function getSslMode(): String;
    declare function getKerberosName(): String;
    declare function getService(): String;
    declare function getConnectionPoolSize(): Int32;
    declare function isLoggingEnabled(): Boolean;
    static declare function getSqlite3Backend(): NJSDatabaseBackend;
    static declare function getPostgreSQLBackend(): NJSDatabaseBackend;
}
declare class NJSRandomNumberGenerator
{
    declare function getRandomBytes(Int32: size): Object;
    declare function getRandomInt(): Int32;
    declare function getRandomLong(): Number;
    declare function getRandomByte(): Int;
}
declare class NJSEthereumPublicKeyProvider
{
}
declare class NJSGetEthreumLikeWalletCallback
{
    declare function onSuccess(NJSEthereumLikeWallet: wallet, Boolean: isCreated)
    declare function onError(Error: error)
}
declare class NJSEthereumLikeWallet
{
}
declare class NJSBitcoinLikeAddress
{
    /**
     * Gets the version of the address (P2SH or P2PKH)
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): BitcoinLikeNetworkParameters;
    /**
     * Serializes the hash160 into a Base58 encoded address (with checksum)
     * @return The Base58 serialization
     */
    declare function toBase58(): String;
    /**
     * Serializes the hash160 to a payment uri (i.e bitcoin:16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM)
     * @return A payment uri to this address
     * toPaymentUri(): string;
     * Checks if the given address is a P2SH address
     * @return True if the version byte matches the P2SH byte version of the address network parameters
     */
    declare function isP2SH(): Boolean;
    /**
     * Checks if the given address is a P2PKH address
     * @return True if the version byte matches the P2PKH byte version of the address network parameters
     */
    declare function isP2PKH(): Boolean;
    /**
     * Gets an optional derivation path (if the address comes from an extended public key)
     * @return The derivation path of the address
     */
    declare function getDerivationPath(): MaybeLocal;
    /**
     * Deserializes the given address (note that this function will throw an exception wether the address doesn't belong to
     * the given network parameters, or if the address contains invalid Base58 characters or if the checksum is invalid).
     * @return A BitcoinLikeAddress
     */
    static declare function fromBase58(BitcoinLikeNetworkParameters: params, String: address): NJSBitcoinLikeAddress;
    /**
     * Check if the given address is valid
     * @return true if the address is valid, false otherwise
     */
    static declare function isAddressValid(BitcoinLikeNetworkParameters: params, String: address): Boolean;
}
declare class NJSBitcoinLikeExtendedPublicKey
{
    declare function derive(String: path): NJSBitcoinLikeAddress;
    declare function toBase58(): String;
    declare function getRootPath(): String;
    static declare function fromBase58(BitcoinLikeNetworkParameters: params, String: address, MaybeLocal: path): NJSBitcoinLikeExtendedPublicKey;
}
declare class NJSAmount
{
    declare function toBigInt(): NJSBigInt;
    declare function getCurrency(): Currency;
    declare function getUnit(): CurrencyUnit;
    declare function toUnit(CurrencyUnit: unit): NJSAmount;
    declare function toMagnitude(Int32: magnitude): NJSAmount;
    declare function toString(): String;
    declare function toLong(): Number;
    declare function toDouble(): Number;
    declare function format(Locale: locale, MaybeLocal: rules): String;
}
declare class NJSPreferences
{
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getString(String: key, String: fallbackValue): String;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getInt(String: key, Int32: fallbackValue): Int32;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getLong(String: key, Number: fallbackValue): Number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getBoolean(String: key, Boolean: fallbackValue): Boolean;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getStringArray(String: key, Array: fallbackValue): Array;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getData(String: key, Object: fallbackValue): Object;
    /**
     * Checks whether the Preferences contains the given key.
     * @return true the preferences contains the key, false otherwise.
     */
    declare function contains(String: key): Boolean;
    /**
     * Get a preferences editor in order to add/modify/remove data.
     * @return An interface for editting preferences.
     */
    declare function edit(): NJSPreferencesEditor;
}
declare class NJSPreferencesEditor
{
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putString(String: key, String: value): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putInt(String: key, Int32: value): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putLong(String: key, Number: value): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putBoolean(String: key, Boolean: value): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putStringArray(String: key, Array: value): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putData(String: key, Object: value): NJSPreferencesEditor;
    /**
     * Removes the data associated with the given key.
     * @param key The key to remove from the Preferences
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function remove(String: key): NJSPreferencesEditor;
    /** Persists the changes to the Preferences. */
    declare function commit()
}
declare class NJSBitcoinLikeWalletConfiguration
{
}
declare class NJSBitcoinLikeInput
{
    declare function getAddress(): MaybeLocal;
    declare function getValue(): NJSAmount;
    declare function isCoinbase(): Boolean;
    declare function getCoinbase(): MaybeLocal;
    declare function getPreviousTxHash(): MaybeLocal;
    declare function getPreviousOutputIndex(): MaybeLocal;
}
declare class NJSBitcoinLikeOutput
{
    declare function getTransactionHash(): String;
    declare function getOutputIndex(): Int32;
    declare function getValue(): NJSAmount;
    declare function getScript(): Object;
    declare function getAddress(): MaybeLocal;
}
declare class NJSBitcoinLikeBlock
{
    declare function getHash(): String;
    declare function getHeight(): Number;
    declare function getTime(): Date;
}
declare class NJSBitcoinLikeTransaction
{
    declare function getHash(): String;
    declare function getInputs(): Array;
    declare function getOutputs(): Array;
    declare function getBlock(): NJSBitcoinLikeBlock;
    declare function getLockTime(): Number;
    declare function getFees(): NJSAmount;
    declare function getTime(): Date;
}
declare class NJSBitcoinLikeOperation
{
    declare function getTransaction(): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeHelper
{
    static declare function scriptToOutput(Object: script, NJSAmount: amount): NJSBitcoinLikeOutput;
    static declare function addressToOutput(String: address, NJSAmount: amount): NJSBitcoinLikeOutput;
    static declare function serializeTransaction(BitcoinLikePreparedTransaction: preparedTransaction): Object;
    static declare function parseTransaction(Object: transaction): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeAccount
{
    declare function getUTXO(Int32: from, Int32: to, NJSBitcoinLikeOutputListCallback: callback)
    declare function getUTXOCount(NJSI32Callback: callback)
    declare function pickUTXO(NJSAmount: baseFees, Array: outputs, BitcoinLikePickingStrategy: strategy, NJSBitcoinLikeTransactionRequestCallback: callback)
    declare function estimateFees(BitcoinLikeTransactionRequest: request, NJSBitcoinLikeTransactionRequestCallback: callback)
    declare function prepareTransaction(BitcoinLikeTransactionRequest: request, NJSBitcoinLikePreparedTransactionCallback: callback)
    declare function broadcastTransaction(Object: transaction, NJSStringCallback: callback)
}
declare class NJSBitcoinLikeOutputListCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSBitcoinLikeTransactionRequestCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSBitcoinLikePreparedTransactionCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSStringCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSBitcoinLikeWallet
{
}
declare class NJSWalletPool
{
    declare function getLogger(): NJSLogger;
    declare function getName(): String;
    declare function getPreferences(): NJSPreferences;
    declare function getWalletCount(NJSI32Callback: callback)
    declare function getWallets(Int32: from, Int32: size, NJSWalletListCallback: callback)
    declare function getWallet(String: name, NJSWalletCallback: callback)
    declare function createWallet(String: name, Currency: currency, NJSDynamicObject: configuration, NJSWalletCallback: callback)
    declare function getCurrencies(NJSCurrencyListCallback: callback)
    declare function getCurrency(String: name, NJSCurrencyCallback: callback)
    declare function getLastBlock(String: currencyName, NJSBlockCallback: callback)
    declare function getEventBus(): NJSEventBus;
}
declare class NJSWalletListCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSWalletCallback
{
    declare function onCallback(NJSWallet: result, MaybeLocal: error)
}
declare class NJSCurrencyListCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSCurrencyCallback
{
    declare function onCallback(MaybeLocal: result, MaybeLocal: error)
}
declare class NJSWalletPoolBuilder
{
    declare function setHttpClient(NJSHttpClient: client): NJSWalletPoolBuilder;
    declare function setWebsocketClient(NJSWebSocketClient: client): NJSWalletPoolBuilder;
    declare function setPathResolver(NJSPathResolver: pathResolver): NJSWalletPoolBuilder;
    declare function setLogPrinter(NJSLogPrinter: printer): NJSWalletPoolBuilder;
    declare function setThreadDispatcher(NJSThreadDispatcher: dispatcher): NJSWalletPoolBuilder;
    declare function setName(String: name): NJSWalletPoolBuilder;
    declare function setPassword(String: password): NJSWalletPoolBuilder;
    declare function setRandomNumberGenerator(NJSRandomNumberGenerator: rng): NJSWalletPoolBuilder;
    declare function setDatabaseBackend(NJSDatabaseBackend: backend): NJSWalletPoolBuilder;
    declare function setConfiguration(NJSDynamicObject: configuration): NJSWalletPoolBuilder;
    declare function build(NJSWalletPoolCallback: listener)
    static declare function createInstance(): NJSWalletPoolBuilder;
}
declare class NJSWalletPoolCallback
{
    declare function onCallback(NJSWalletPool: result, MaybeLocal: error)
}
declare class NJSWebSocketConnection
{
    declare function onConnect(Int32: connectionId)
    declare function onClose()
    declare function onMessage(String: data)
    declare function onError(ErrorCode: code, String: message)
    declare function getConnectionId(): Int32;
}
declare class NJSWebSocketClient
{
    declare function connect(String: url, NJSWebSocketConnection: connection)
    declare function send(NJSWebSocketConnection: connection, String: data)
    declare function disconnect(NJSWebSocketConnection: connection)
}
declare class NJSHttpUrlConnection
{
    /**
     * Gets the HTTP response status code
     * @return The HTTP response status code
     */
    declare function getStatusCode(): Int32;
    /**
     * Gets the HTTP response status text
     * @return The HTTP response status text
     */
    declare function getStatusText(): String;
    /**
     * Gets the HTTP response headers
     * @return The HTTP response headers
     */
    declare function getHeaders(): Map;
    /**
     * Reads available HTTP response body. This method will be called multiple times until it returns a empty bytes array.
     * @returns A chunk of the body data wrapped into a HttpReadBodyResult (for error management)
     */
    declare function readBody(): HttpReadBodyResult;
}
declare class NJSHttpRequest
{
    declare function getMethod(): HttpMethod;
    declare function getHeaders(): Map;
    declare function getBody(): Object;
    declare function getUrl(): String;
    declare function complete(NJSHttpUrlConnection: response, MaybeLocal: error)
}
declare class NJSHttpClient
{
    declare function execute(NJSHttpRequest: request)
}
declare class NJSBigInt
{
    /**
     * Adds two BigInt and returns a new BigInt with the result.
     * @params i Value to be added to this BigInt
     * @return The result of this + i
     */
    declare function add(NJSBigInt: i): NJSBigInt;
    /**
     * Subtracts two BigInt and returns a new BigInt with result.
     * @params i Value to be subtracted to this BigInt
     * @return The result of this - i
     */
    declare function subtract(NJSBigInt: i): NJSBigInt;
    /**
     * Multiplies two BigInt and returns a new BigInt with result.
     * @params i Value to be multiplied by this BigInt
     * @return The result of this * i
     */
    declare function multiply(NJSBigInt: i): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result.
     * @params i Value by which this BigInt will be divided
     * @return The result of this / i
     */
    declare function divide(NJSBigInt: i): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
     * @params i Value by which this BigInteger is to be divided, and the remainder computed
     * @return A tuple of [this / i, this % i]
     */
    declare function divideAndRemainder(NJSBigInt: i): Array;
    /**
     * Raises this BigInt with an interger value.
     * @params i The exponent to which thi BigInt is raised
     * @return The result of this ^ exponent
     */
    declare function pow(Int32: exponent): NJSBigInt;
    /**
     * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
     * @params precision The power of ten by wich this BigInt is divided
     * @params decimalSeparator The separator to use between the integer part and the decimal part
     * @params thousandSeparator The separator to use between each group of thousand units
     * @return The BigInt formatted as a decimal string
     */
    declare function toDecimalString(Int32: precision, String: decimalSeparator, String: thousandSeparator): String;
    /**
     * Formats this BigInt to the interger representation of its internal value.
     * @params radix The radix of the number representation in which to format (right now 10 or 16)
     */
    declare function toString(Int32: radix): String;
    /**
     * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
     * will be meaningless.
     * @return The int representation of this BigInt
     */
    declare function intValue(): Int32;
    /**
     * Compares two BigInt together.
     * @param i The value to compare with this BigInt
     * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
     */
    declare function compare(NJSBigInt: i): Int32;
    /**
     * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
     * are ignored (e.g. "1ledger000" will be equal to "1000")
     * @param s The string with the decimal representation of the BigInt
     * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
     * @params decimalSeparator The decimal separator used by this string representation
     * @return The created BigInt
     */
    static declare function fromDecimalString(String: s, Int32: precision, String: decimalSeparator): NJSBigInt;
    /**
     * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
     * @param s The string to parse
     * @param radix The radix of the number representation (right now 10 or 16)
     * @return The created BigInt
     */
    static declare function fromIntegerString(String: s, Int32: radix): NJSBigInt;
    /**
     * Creates a BigInt from a int64 value
     * @param l The value to convert
     * @return The created BigInt
     */
    static declare function fromLong(Number: l): NJSBigInt;
}
declare class NJSPathResolver
{
    /**
     * Resolves the path for a SQLite database file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveDatabasePath(String: path): String;
    /**
     * Resolves the path of a single log file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveLogFilePath(String: path): String;
    /**
     * Resolves the path for a json file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolvePreferencesPath(String: path): String;
}
declare class NJSRunnable
{
    declare function run()
}
declare class NJSLock
{
    declare function lock()
    declare function tryLock(): Boolean;
    declare function unlock()
}
declare class NJSExecutionContext
{
    /** */
    declare function execute(NJSRunnable: runnable)
    declare function delay(NJSRunnable: runnable, Number: millis)
}
declare class NJSThreadDispatcher
{
    declare function getSerialExecutionContext(String: name): NJSExecutionContext;
    declare function getThreadPoolExecutionContext(String: name): NJSExecutionContext;
    declare function getMainExecutionContext(): NJSExecutionContext;
    declare function newLock(): NJSLock;
}
declare class NJSLogPrinter
{
    declare function printError(String: message)
    declare function printInfo(String: message)
    declare function printDebug(String: message)
    declare function printWarning(String: message)
    declare function printApdu(String: message)
    declare function printCriticalError(String: message)
    declare function getContext(): NJSExecutionContext;
}
declare class NJSLogger
{
    declare function d(String: tag, String: message)
    declare function i(String: tag, String: message)
    declare function e(String: tag, String: message)
    declare function w(String: tag, String: message)
    declare function c(String: tag, String: message)
}
declare class NJSLedgerCore
{
    /**
     * Gets the version of the library as a human readable string.
     * @return The version of the library (e.g. '1.0.1')
     */
    static declare function getStringVersion(): String;
    /**
     * Get the integer version of the Library
     * @return The integer version of the library
     */
    static declare function getIntVersion(): Int32;
}
