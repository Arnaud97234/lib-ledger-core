// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni

declare class NJSSecp256k1
{
    declare function computePubKey(privKey: Object, compress: Boolean): Object;
    declare function sign(privKey: Object, data: Object): Object;
    declare function verify(data: Object, signature: Object, pubKey: Object): Boolean;
    static declare function newInstance(): NJSSecp256k1;
}
declare class NJSNetworks
{
    static declare function bitcoin(): BitcoinLikeNetworkParameters;
}
declare class NJSHashAlgorithmHelper
{
    declare function ripemd160(data: Object): Object;
    declare function sha256(data: Object): Object;
    declare function keccak256(data: Object): Object;
}
declare class NJSEvent
{
    declare function getCode(): EventCode;
    declare function getPayload(): NJSDynamicObject;
    declare function isSticky(): Boolean;
    declare function getStickyTag(): Int32;
    static declare function newInstance(code: EventCode, payload: NJSDynamicObject): NJSEvent;
}
declare class NJSEventReceiver
{
    declare function onEvent(event: NJSEvent)
}
declare class NJSEventBus
{
    declare function subscribe(context: NJSExecutionContext, receiver: NJSEventReceiver)
    declare function unsubscribe(receiver: NJSEventReceiver)
}
declare class NJSEventPublisher
{
    declare function getEventBus(): NJSEventBus;
    declare function post(event: NJSEvent)
    declare function postSticky(event: NJSEvent, tag: Int32)
    declare function relay(bus: NJSEventBus)
    static declare function newInstance(context: NJSExecutionContext): NJSEventPublisher;
}
declare class NJSSynchronizationStatus
{
}
declare class NJSTrustIndicator
{
    declare function getTrustWeight(): Int32;
    declare function getTrustLevel(): TrustLevel;
    declare function getConflictingOperationUids(): Array;
    declare function getOrigin(): String;
}
declare class NJSOperation
{
    declare function getUid(): String;
    declare function getAccountIndex(): Int32;
    declare function getOperationType(): OperationType;
    declare function getDate(): Date;
    declare function getSenders(): Array;
    declare function getRecipients(): Array;
    declare function getAmount(): NJSAmount;
    declare function getFees(): NJSAmount;
    declare function getPreferences(): NJSPreferences;
    declare function getTrust(): NJSTrustIndicator;
    declare function getBlockHeight(): MaybeLocal;
    declare function asBitcoinLikeOperation(): NJSBitcoinLikeOperation;
    /**
     *# asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
     *# asRippleLikeOperation(): Callback<RippleLikeEthereum>;
     */
    declare function isInstanceOfBitcoinLikeOperation(): Boolean;
    declare function isInstanceOfEthereumLikeOperation(): Boolean;
    declare function isInstanceOfRippleLikeOperation(): Boolean;
    declare function isComplete(): Boolean;
    declare function getWalletType(): WalletType;
}
declare class NJSQueryFilter
{
    static declare function accountEq(accountUid: String): NJSQueryFilter;
    static declare function accountNeq(accountUid: String): NJSQueryFilter;
    static declare function dateLte(time: Date): NJSQueryFilter;
    static declare function dateLt(time: Date): NJSQueryFilter;
    static declare function dateGt(time: Date): NJSQueryFilter;
    static declare function dateGte(time: Date): NJSQueryFilter;
    static declare function dateEq(time: Date): NJSQueryFilter;
    static declare function dateNeq(time: Date): NJSQueryFilter;
    static declare function containsRecipient(recipientAddress: String): NJSQueryFilter;
    static declare function containsSender(senderAddress: String): NJSQueryFilter;
    static declare function currencyEq(currencyName: String): NJSQueryFilter;
    static declare function operationUidEq(operationUid: String): NJSQueryFilter;
    static declare function operationUidNeq(operationUid: String): NJSQueryFilter;
    static declare function trustEq(trust: TrustLevel): NJSQueryFilter;
    static declare function trustNeq(trust: TrustLevel): NJSQueryFilter;
    static declare function feesEq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGt(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountEq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLt(amount: NJSAmount): NJSQueryFilter;
    static declare function blockHeightEq(blockHeight: Number): NJSQueryFilter;
    static declare function blockHeightNeq(blockHeight: Number): NJSQueryFilter;
    static declare function blockHeightGte(blockHeight: Number): NJSQueryFilter;
    static declare function blockHeightGt(blockHeight: Number): NJSQueryFilter;
    static declare function blockHeightLte(blockHeight: Number): NJSQueryFilter;
    static declare function blockHeightLt(blockHeight: Number): NJSQueryFilter;
    static declare function blockHeightIsNull(): NJSQueryFilter;
    static declare function operationTypeEq(operationType: OperationType): NJSQueryFilter;
    static declare function operationTypeNeq(operationType: OperationType): NJSQueryFilter;
    declare function op_and(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_and_not(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or_not(filter: NJSQueryFilter): NJSQueryFilter;
}
declare class NJSOperationQuery
{
    declare function addOrder(key: OperationOrderKey, descending: Boolean): NJSOperationQuery;
    declare function filter(): NJSQueryFilter;
    declare function offset(from: Number): NJSOperationQuery;
    declare function limit(count: Number): NJSOperationQuery;
    declare function complete(): NJSOperationQuery;
    declare function partial(): NJSOperationQuery;
    declare function execute(callback: NJSOperationListCallback)
}
declare class NJSOperationListCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSAccount
{
    declare function getIndex(): Int32;
    declare function queryOperations(): NJSOperationQuery;
    declare function getBalance(callback: NJSAmountCallback)
    declare function isSynchronizing(): Boolean;
    declare function synchronize(): NJSEventBus;
    declare function getPreferences(): NJSPreferences;
    declare function getLogger(): NJSLogger;
    declare function getOperationPreferences(uid: String): NJSPreferences;
    /**
     * asBitcoinLikeAccount(): Callback<BitcoinLikeAccount>;
     * asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
     * asRippleLikeAccount(): Callback<RippleLikeAccount>;
     */
    declare function isInstanceOfBitcoinLikeAccount(): Boolean;
    declare function isInstanceOfEthereumLikeAccount(): Boolean;
    declare function isInstanceOfRippleLikeAccount(): Boolean;
    declare function getFreshPublicAddresses(callback: NJSStringListCallback)
    declare function getWalletType(): WalletType;
    declare function getEventBus(): NJSEventBus;
    declare function startBlockchainObservation()
    declare function stopBlockchainObservation()
    declare function isObservingBlockchain(): Boolean;
    declare function getLastBlock(callback: NJSBlockCallback)
    declare function computeFees(amount: NJSAmount, priority: Int32, recipients: Array, data: Array, callback: NJSAmountCallback)
}
declare class NJSAmountCallback
{
    declare function onCallback(result: NJSAmount, error: MaybeLocal)
}
declare class NJSStringListCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSBlockCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSWallet
{
    declare function getName(): String;
    declare function getAccount(index: Int32, callback: NJSAccountCallback)
    declare function getAccountCount(callback: NJSI32Callback)
    declare function getAccounts(offset: Int32, count: Int32, callback: NJSAccountListCallback)
    declare function getNextAccountIndex(callback: NJSI32Callback)
    declare function getEventBus(): NJSEventBus;
    declare function isSynchronizing(): Boolean;
    declare function synchronize(): NJSEventBus;
    declare function getPreferences(): NJSPreferences;
    declare function getLogger(): NJSLogger;
    declare function getAccountPreferences(index: Int32): NJSPreferences;
    /**
     * asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
     * asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
     * asRippleLikeWallet(): Callback<RippleLikeWallet>;
     */
    declare function asBitcoinLikeWallet(): NJSBitcoinLikeWallet;
    declare function getCurrency(): Currency;
    declare function isInstanceOfBitcoinLikeWallet(): Boolean;
    declare function isInstanceOfEthereumLikeWallet(): Boolean;
    declare function isInstanceOfRippleLikeWallet(): Boolean;
    declare function getWalletType(): WalletType;
    declare function getLastBlock(callback: NJSBlockCallback)
    declare function getAccountCreationInfo(accountIndex: Int32, callback: NJSAccountCreationInfoCallback)
    declare function getExtendedKeyAccountCreationInfo(accountIndex: Int32, callback: NJSExtendedKeyAccountCreationInfoCallback)
    declare function getNextAccountCreationInfo(callback: NJSAccountCreationInfoCallback)
    declare function getNextExtendedKeyAccountCreationInfo(callback: NJSExtendedKeyAccountCreationInfoCallback)
    declare function newAccountWithInfo(accountCreationInfo: AccountCreationInfo, callback: NJSAccountCallback)
    declare function newAccountWithExtendedKeyInfo(extendedKeyAccountCreationInfo: ExtendedKeyAccountCreationInfo, callback: NJSAccountCallback)
}
declare class NJSAccountCallback
{
    declare function onCallback(result: NJSAccount, error: MaybeLocal)
}
declare class NJSI32Callback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSAccountListCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSAccountCreationInfoCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSExtendedKeyAccountCreationInfoCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSDynamicArray
{
    declare function size(): Number;
    declare function getString(index: Number): MaybeLocal;
    declare function getInt(index: Number): MaybeLocal;
    declare function getLong(index: Number): MaybeLocal;
    declare function getDouble(index: Number): MaybeLocal;
    declare function getData(index: Number): MaybeLocal;
    declare function getBoolean(index: Number): MaybeLocal;
    declare function pushInt(value: Int32): NJSDynamicArray;
    declare function pushLong(value: Number): NJSDynamicArray;
    declare function pushString(value: String): NJSDynamicArray;
    declare function pushDouble(value: Number): NJSDynamicArray;
    declare function pushData(value: Object): NJSDynamicArray;
    declare function pushBoolean(value: Boolean): NJSDynamicArray;
    declare function getObject(index: Number): NJSDynamicObject;
    declare function getArray(index: Number): NJSDynamicArray;
    declare function pushObject(value: NJSDynamicObject): NJSDynamicArray;
    declare function pushArray(value: NJSDynamicArray): NJSDynamicArray;
    declare function concat(array: NJSDynamicArray): NJSDynamicArray;
    declare function getType(index: Number): MaybeLocal;
    declare function remove(index: Number): Boolean;
    declare function dump(): String;
    declare function serialize(): Object;
    declare function isReadOnly(): Boolean;
    static declare function newInstance(): NJSDynamicArray;
    static declare function load(serialized: Object): NJSDynamicArray;
}
declare class NJSDynamicObject
{
    declare function isReadOnly(): Boolean;
    declare function putString(key: String, value: String): NJSDynamicObject;
    declare function putInt(key: String, value: Int32): NJSDynamicObject;
    declare function putLong(key: String, value: Number): NJSDynamicObject;
    declare function putDouble(key: String, value: Number): NJSDynamicObject;
    declare function putData(key: String, value: Object): NJSDynamicObject;
    declare function putBoolean(key: String, value: Boolean): NJSDynamicObject;
    declare function getString(key: String): MaybeLocal;
    declare function getInt(key: String): MaybeLocal;
    declare function getLong(key: String): MaybeLocal;
    declare function getDouble(key: String): MaybeLocal;
    declare function getData(key: String): MaybeLocal;
    declare function getBoolean(key: String): MaybeLocal;
    declare function putObject(key: String, value: NJSDynamicObject): NJSDynamicObject;
    declare function putArray(key: String, value: NJSDynamicArray): NJSDynamicObject;
    declare function getObject(key: String): NJSDynamicObject;
    declare function getArray(key: String): NJSDynamicArray;
    declare function contains(key: String): Boolean;
    declare function remove(key: String): Boolean;
    declare function getKeys(): Array;
    declare function getType(key: String): MaybeLocal;
    declare function dump(): String;
    declare function serialize(): Object;
    declare function size(): Number;
    static declare function newInstance(): NJSDynamicObject;
    static declare function load(serialized: Object): NJSDynamicObject;
}
declare class NJSBlockchainExplorerEngines
{
}
declare class NJSBlockchainObserverEngines
{
}
declare class NJSKeychainEngines
{
}
declare class NJSSynchronizerEngines
{
}
declare class NJSSynchronizationEngines
{
}
declare class NJSConfigurationDefaults
{
}
declare class NJSConfiguration
{
}
declare class NJSPoolConfiguration
{
}
declare class NJSDatabaseBackend
{
    declare function setUsername(username: String): NJSDatabaseBackend;
    declare function setPassword(pwd: String): NJSDatabaseBackend;
    declare function setHost(host: String): NJSDatabaseBackend;
    declare function setHostAddr(hostAddr: String): NJSDatabaseBackend;
    declare function setPort(port: String): NJSDatabaseBackend;
    declare function setOptions(opts: String): NJSDatabaseBackend;
    declare function setSslMode(mode: String): NJSDatabaseBackend;
    declare function setKerberosName(name: String): NJSDatabaseBackend;
    declare function setService(service: String): NJSDatabaseBackend;
    declare function setConnectionPoolSize(size: Int32): NJSDatabaseBackend;
    declare function enableQueryLogging(enable: Boolean): NJSDatabaseBackend;
    declare function getUsername(): String;
    declare function getPassword(): String;
    declare function getHost(): String;
    declare function getHostAddr(): String;
    declare function getPort(): String;
    declare function getOptions(): String;
    declare function getSslMode(): String;
    declare function getKerberosName(): String;
    declare function getService(): String;
    declare function getConnectionPoolSize(): Int32;
    declare function isLoggingEnabled(): Boolean;
    static declare function getSqlite3Backend(): NJSDatabaseBackend;
    static declare function getPostgreSQLBackend(): NJSDatabaseBackend;
}
declare class NJSRandomNumberGenerator
{
    declare function getRandomBytes(size: Int32): Object;
    declare function getRandomInt(): Int32;
    declare function getRandomLong(): Number;
    declare function getRandomByte(): Int;
}
declare class NJSEthereumPublicKeyProvider
{
}
declare class NJSGetEthreumLikeWalletCallback
{
    declare function onSuccess(wallet: NJSEthereumLikeWallet, isCreated: Boolean)
    declare function onError(error: Error)
}
declare class NJSEthereumLikeWallet
{
}
declare class NJSBitcoinLikeAddress
{
    /**
     * Gets the version of the address (P2SH or P2PKH)
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): BitcoinLikeNetworkParameters;
    /**
     * Serializes the hash160 into a Base58 encoded address (with checksum)
     * @return The Base58 serialization
     */
    declare function toBase58(): String;
    /**
     * Serializes the hash160 to a payment uri (i.e bitcoin:16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM)
     * @return A payment uri to this address
     * toPaymentUri(): string;
     * Checks if the given address is a P2SH address
     * @return True if the version byte matches the P2SH byte version of the address network parameters
     */
    declare function isP2SH(): Boolean;
    /**
     * Checks if the given address is a P2PKH address
     * @return True if the version byte matches the P2PKH byte version of the address network parameters
     */
    declare function isP2PKH(): Boolean;
    /**
     * Gets an optional derivation path (if the address comes from an extended public key)
     * @return The derivation path of the address
     */
    declare function getDerivationPath(): MaybeLocal;
    /**
     * Deserializes the given address (note that this function will throw an exception wether the address doesn't belong to
     * the given network parameters, or if the address contains invalid Base58 characters or if the checksum is invalid).
     * @return A BitcoinLikeAddress
     */
    static declare function fromBase58(params: BitcoinLikeNetworkParameters, address: String): NJSBitcoinLikeAddress;
    /**
     * Check if the given address is valid
     * @return true if the address is valid, false otherwise
     */
    static declare function isAddressValid(params: BitcoinLikeNetworkParameters, address: String): Boolean;
}
declare class NJSBitcoinLikeExtendedPublicKey
{
    declare function derive(path: String): NJSBitcoinLikeAddress;
    declare function toBase58(): String;
    declare function getRootPath(): String;
    static declare function fromBase58(params: BitcoinLikeNetworkParameters, address: String, path: MaybeLocal): NJSBitcoinLikeExtendedPublicKey;
}
declare class NJSAmount
{
    declare function toBigInt(): NJSBigInt;
    declare function getCurrency(): Currency;
    declare function getUnit(): CurrencyUnit;
    declare function toUnit(unit: CurrencyUnit): NJSAmount;
    declare function toMagnitude(magnitude: Int32): NJSAmount;
    declare function toString(): String;
    declare function toLong(): Number;
    declare function toDouble(): Number;
    declare function format(locale: Locale, rules: MaybeLocal): String;
}
declare class NJSPreferences
{
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getString(key: String, fallbackValue: String): String;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getInt(key: String, fallbackValue: Int32): Int32;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getLong(key: String, fallbackValue: Number): Number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getBoolean(key: String, fallbackValue: Boolean): Boolean;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getStringArray(key: String, fallbackValue: Array): Array;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getData(key: String, fallbackValue: Object): Object;
    /**
     * Checks whether the Preferences contains the given key.
     * @return true the preferences contains the key, false otherwise.
     */
    declare function contains(key: String): Boolean;
    /**
     * Get a preferences editor in order to add/modify/remove data.
     * @return An interface for editting preferences.
     */
    declare function edit(): NJSPreferencesEditor;
}
declare class NJSPreferencesEditor
{
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putString(key: String, value: String): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putInt(key: String, value: Int32): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putLong(key: String, value: Number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putBoolean(key: String, value: Boolean): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putStringArray(key: String, value: Array): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putData(key: String, value: Object): NJSPreferencesEditor;
    /**
     * Removes the data associated with the given key.
     * @param key The key to remove from the Preferences
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function remove(key: String): NJSPreferencesEditor;
    /** Persists the changes to the Preferences. */
    declare function commit()
}
declare class NJSBitcoinLikeWalletConfiguration
{
}
declare class NJSBitcoinLikeInput
{
    declare function getAddress(): MaybeLocal;
    declare function getValue(): NJSAmount;
    declare function isCoinbase(): Boolean;
    declare function getCoinbase(): MaybeLocal;
    declare function getPreviousTxHash(): MaybeLocal;
    declare function getPreviousOutputIndex(): MaybeLocal;
}
declare class NJSBitcoinLikeOutput
{
    declare function getTransactionHash(): String;
    declare function getOutputIndex(): Int32;
    declare function getValue(): NJSAmount;
    declare function getScript(): Object;
    declare function getAddress(): MaybeLocal;
}
declare class NJSBitcoinLikeBlock
{
    declare function getHash(): String;
    declare function getHeight(): Number;
    declare function getTime(): Date;
}
declare class NJSBitcoinLikeTransaction
{
    declare function getHash(): String;
    declare function getInputs(): Array;
    declare function getOutputs(): Array;
    declare function getBlock(): NJSBitcoinLikeBlock;
    declare function getLockTime(): Number;
    declare function getFees(): NJSAmount;
    declare function getTime(): Date;
}
declare class NJSBitcoinLikeOperation
{
    declare function getTransaction(): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeHelper
{
    static declare function scriptToOutput(script: Object, amount: NJSAmount): NJSBitcoinLikeOutput;
    static declare function addressToOutput(address: String, amount: NJSAmount): NJSBitcoinLikeOutput;
    static declare function serializeTransaction(preparedTransaction: BitcoinLikePreparedTransaction): Object;
    static declare function parseTransaction(transaction: Object): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeAccount
{
    declare function getUTXO(from: Int32, to: Int32, callback: NJSBitcoinLikeOutputListCallback)
    declare function getUTXOCount(callback: NJSI32Callback)
    declare function pickUTXO(baseFees: NJSAmount, outputs: Array, strategy: BitcoinLikePickingStrategy, callback: NJSBitcoinLikeTransactionRequestCallback)
    declare function estimateFees(request: BitcoinLikeTransactionRequest, callback: NJSBitcoinLikeTransactionRequestCallback)
    declare function prepareTransaction(request: BitcoinLikeTransactionRequest, callback: NJSBitcoinLikePreparedTransactionCallback)
    declare function broadcastTransaction(transaction: Object, callback: NJSStringCallback)
}
declare class NJSBitcoinLikeOutputListCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSBitcoinLikeTransactionRequestCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSBitcoinLikePreparedTransactionCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSStringCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSBitcoinLikeWallet
{
}
declare class NJSWalletPool
{
    declare function getLogger(): NJSLogger;
    declare function getName(): String;
    declare function getPreferences(): NJSPreferences;
    declare function getWalletCount(callback: NJSI32Callback)
    declare function getWallets(from: Int32, size: Int32, callback: NJSWalletListCallback)
    declare function getWallet(name: String, callback: NJSWalletCallback)
    declare function createWallet(name: String, currency: Currency, configuration: NJSDynamicObject, callback: NJSWalletCallback)
    declare function getCurrencies(callback: NJSCurrencyListCallback)
    declare function getCurrency(name: String, callback: NJSCurrencyCallback)
    declare function getLastBlock(currencyName: String, callback: NJSBlockCallback)
    declare function getEventBus(): NJSEventBus;
}
declare class NJSWalletListCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSWalletCallback
{
    declare function onCallback(result: NJSWallet, error: MaybeLocal)
}
declare class NJSCurrencyListCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSCurrencyCallback
{
    declare function onCallback(result: MaybeLocal, error: MaybeLocal)
}
declare class NJSWalletPoolBuilder
{
    declare function setHttpClient(client: NJSHttpClient): NJSWalletPoolBuilder;
    declare function setWebsocketClient(client: NJSWebSocketClient): NJSWalletPoolBuilder;
    declare function setPathResolver(pathResolver: NJSPathResolver): NJSWalletPoolBuilder;
    declare function setLogPrinter(printer: NJSLogPrinter): NJSWalletPoolBuilder;
    declare function setThreadDispatcher(dispatcher: NJSThreadDispatcher): NJSWalletPoolBuilder;
    declare function setName(name: String): NJSWalletPoolBuilder;
    declare function setPassword(password: String): NJSWalletPoolBuilder;
    declare function setRandomNumberGenerator(rng: NJSRandomNumberGenerator): NJSWalletPoolBuilder;
    declare function setDatabaseBackend(backend: NJSDatabaseBackend): NJSWalletPoolBuilder;
    declare function setConfiguration(configuration: NJSDynamicObject): NJSWalletPoolBuilder;
    declare function build(listener: NJSWalletPoolCallback)
    static declare function createInstance(): NJSWalletPoolBuilder;
}
declare class NJSWalletPoolCallback
{
    declare function onCallback(result: NJSWalletPool, error: MaybeLocal)
}
declare class NJSWebSocketConnection
{
    declare function onConnect(connectionId: Int32)
    declare function onClose()
    declare function onMessage(data: String)
    declare function onError(code: ErrorCode, message: String)
    declare function getConnectionId(): Int32;
}
declare class NJSWebSocketClient
{
    declare function connect(url: String, connection: NJSWebSocketConnection)
    declare function send(connection: NJSWebSocketConnection, data: String)
    declare function disconnect(connection: NJSWebSocketConnection)
}
declare class NJSHttpUrlConnection
{
    /**
     * Gets the HTTP response status code
     * @return The HTTP response status code
     */
    declare function getStatusCode(): Int32;
    /**
     * Gets the HTTP response status text
     * @return The HTTP response status text
     */
    declare function getStatusText(): String;
    /**
     * Gets the HTTP response headers
     * @return The HTTP response headers
     */
    declare function getHeaders(): Map;
    /**
     * Reads available HTTP response body. This method will be called multiple times until it returns a empty bytes array.
     * @returns A chunk of the body data wrapped into a HttpReadBodyResult (for error management)
     */
    declare function readBody(): HttpReadBodyResult;
}
declare class NJSHttpRequest
{
    declare function getMethod(): HttpMethod;
    declare function getHeaders(): Map;
    declare function getBody(): Object;
    declare function getUrl(): String;
    declare function complete(response: NJSHttpUrlConnection, error: MaybeLocal)
}
declare class NJSHttpClient
{
    declare function execute(request: NJSHttpRequest)
}
declare class NJSBigInt
{
    /**
     * Adds two BigInt and returns a new BigInt with the result.
     * @params i Value to be added to this BigInt
     * @return The result of this + i
     */
    declare function add(i: NJSBigInt): NJSBigInt;
    /**
     * Subtracts two BigInt and returns a new BigInt with result.
     * @params i Value to be subtracted to this BigInt
     * @return The result of this - i
     */
    declare function subtract(i: NJSBigInt): NJSBigInt;
    /**
     * Multiplies two BigInt and returns a new BigInt with result.
     * @params i Value to be multiplied by this BigInt
     * @return The result of this * i
     */
    declare function multiply(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result.
     * @params i Value by which this BigInt will be divided
     * @return The result of this / i
     */
    declare function divide(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
     * @params i Value by which this BigInteger is to be divided, and the remainder computed
     * @return A tuple of [this / i, this % i]
     */
    declare function divideAndRemainder(i: NJSBigInt): Array;
    /**
     * Raises this BigInt with an interger value.
     * @params i The exponent to which thi BigInt is raised
     * @return The result of this ^ exponent
     */
    declare function pow(exponent: Int32): NJSBigInt;
    /**
     * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
     * @params precision The power of ten by wich this BigInt is divided
     * @params decimalSeparator The separator to use between the integer part and the decimal part
     * @params thousandSeparator The separator to use between each group of thousand units
     * @return The BigInt formatted as a decimal string
     */
    declare function toDecimalString(precision: Int32, decimalSeparator: String, thousandSeparator: String): String;
    /**
     * Formats this BigInt to the interger representation of its internal value.
     * @params radix The radix of the number representation in which to format (right now 10 or 16)
     */
    declare function toString(radix: Int32): String;
    /**
     * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
     * will be meaningless.
     * @return The int representation of this BigInt
     */
    declare function intValue(): Int32;
    /**
     * Compares two BigInt together.
     * @param i The value to compare with this BigInt
     * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
     */
    declare function compare(i: NJSBigInt): Int32;
    /**
     * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
     * are ignored (e.g. "1ledger000" will be equal to "1000")
     * @param s The string with the decimal representation of the BigInt
     * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
     * @params decimalSeparator The decimal separator used by this string representation
     * @return The created BigInt
     */
    static declare function fromDecimalString(s: String, precision: Int32, decimalSeparator: String): NJSBigInt;
    /**
     * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
     * @param s The string to parse
     * @param radix The radix of the number representation (right now 10 or 16)
     * @return The created BigInt
     */
    static declare function fromIntegerString(s: String, radix: Int32): NJSBigInt;
    /**
     * Creates a BigInt from a int64 value
     * @param l The value to convert
     * @return The created BigInt
     */
    static declare function fromLong(l: Number): NJSBigInt;
}
declare class NJSPathResolver
{
    /**
     * Resolves the path for a SQLite database file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveDatabasePath(path: String): String;
    /**
     * Resolves the path of a single log file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveLogFilePath(path: String): String;
    /**
     * Resolves the path for a json file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolvePreferencesPath(path: String): String;
}
declare class NJSRunnable
{
    declare function run()
}
declare class NJSLock
{
    declare function lock()
    declare function tryLock(): Boolean;
    declare function unlock()
}
declare class NJSExecutionContext
{
    /** */
    declare function execute(runnable: NJSRunnable)
    declare function delay(runnable: NJSRunnable, millis: Number)
}
declare class NJSThreadDispatcher
{
    declare function getSerialExecutionContext(name: String): NJSExecutionContext;
    declare function getThreadPoolExecutionContext(name: String): NJSExecutionContext;
    declare function getMainExecutionContext(): NJSExecutionContext;
    declare function newLock(): NJSLock;
}
declare class NJSLogPrinter
{
    declare function printError(message: String)
    declare function printInfo(message: String)
    declare function printDebug(message: String)
    declare function printWarning(message: String)
    declare function printApdu(message: String)
    declare function printCriticalError(message: String)
    declare function getContext(): NJSExecutionContext;
}
declare class NJSLogger
{
    declare function d(tag: String, message: String)
    declare function i(tag: String, message: String)
    declare function e(tag: String, message: String)
    declare function w(tag: String, message: String)
    declare function c(tag: String, message: String)
}
declare class NJSLedgerCore
{
    /**
     * Gets the version of the library as a human readable string.
     * @return The version of the library (e.g. '1.0.1')
     */
    static declare function getStringVersion(): String;
    /**
     * Get the integer version of the Library
     * @return The integer version of the library
     */
    static declare function getIntVersion(): Int32;
}
